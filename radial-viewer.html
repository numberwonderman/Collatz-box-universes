<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Radial Viewer</title>
    </head>
<body>
    <h1>Collatz Radial Viewer</h1>

    <canvas id="radialViewerCanvas" style="border: 1px solid #ccc;"></canvas>

    <script>
        // --- Global Variables for Radial Viewer ---
        // (Keep all your existing global variables here)
        let canvas;
        let ctx;
        let centerX;
        let centerY;
        let translateX = 0;
        let translateY = 0;
        let scale = 1;
        const DEFAULT_NODE_RADIUS = 10;
        const minNodeRadius = 3;
        const maxNodeRadius = 15;
        const minLineThickness = 1;
        const maxLineThickness = 4;
        const DEFAULT_NODE_COLOR = '#4CAF50';
        const DEFAULT_NODE_BORDER_COLOR = '#212121';
        const DEFAULT_LINE_COLOR = '#9E9E9E';
        const DEFAULT_MODULUS = 9;
        // --- End Global Variables ---

        // Your render9Net function (keep it as is)
        function render9Net(data, modulus = DEFAULT_MODULUS) {
            console.log("Radial Viewer: render9Net called.");
            if (!canvas) {
                canvas = document.getElementById('radialViewerCanvas');
                ctx = canvas.getContext('2d');
            }
            const pig=2; // This line is fine

            const dpi = window.devicePixelRatio || 1;
            canvas.width = canvas.offsetWidth * dpi;
            canvas.height = canvas.offsetHeight * dpi;
            ctx.scale(dpi, dpi);

            centerX = canvas.offsetWidth / 2;
            centerY = canvas.offsetHeight / 2;
            nodeRadius = DEFAULT_NODE_RADIUS;

            ctx.clearRect(0, 0, canvas.offsetWidth, canvas.offsetHeight);
            ctx.save();
            ctx.translate(centerX + translateX, centerY + translateY);
            ctx.scale(scale, scale);

            const sequence = data.sequence;
            if (sequence.length < 2) {
                if (sequence.length === 1) {
                    const num = sequence[0];
                    ctx.beginPath();
                    ctx.arc(0, 0, nodeRadius, 0, 2 * Math.PI);
                    ctx.fillStyle = DEFAULT_NODE_COLOR;
                    ctx.fill();
                    ctx.strokeStyle = DEFAULT_NODE_BORDER_COLOR;
                    ctx.lineWidth = 1;
                    ctx.stroke();

                    ctx.fillStyle = '#000';
                    ctx.font = `${Math.max(8, nodeRadius * 0.8)}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(num, 0, 0);
                }
                ctx.restore();
                return;
            }

            const normalizedLength = Math.min(sequence.length, 100);
            nodeRadius = minNodeRadius + (maxNodeRadius - minNodeRadius) * (1 - normalizedLength / 100);
            let lineThickness = minLineThickness + (maxLineThickness - minLineThickness) * (1 - normalizedLength / 100);

            for (let i = 0; i < sequence.length - 1; i++) {
                const startNum = sequence[i];
                const endNum = sequence[i + 1];

                const startAngle = (startNum % modulus) * (2 * Math.PI / modulus);
                const startRadius = 50 + startNum * 0.1;

                const endAngle = (endNum % modulus) * (2 * Math.PI / modulus);
                const endRadius = 50 + endNum * 0.1;

                const x1 = startRadius * Math.cos(startAngle);
                const y1 = startRadius * Math.sin(startAngle);
                const x2 = endRadius * Math.cos(endAngle);
                const y2 = endRadius * Math.sin(endAngle);

                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.strokeStyle = DEFAULT_LINE_COLOR;
                ctx.lineWidth = lineThickness;
                ctx.stroke();
            }

            for (let i = 0; i < sequence.length; i++) {
                const num = sequence[i];
                const angle = (num % modulus) * (2 * Math.PI / modulus);
                const radius = 50 + num * 0.1;

                const x = radius * Math.cos(angle);
                const y = radius * Math.sin(angle);

                ctx.beginPath();
                ctx.arc(x, y, nodeRadius, 0, 2 * Math.PI);
                ctx.fillStyle = DEFAULT_NODE_COLOR;
                ctx.fill();
                ctx.strokeStyle = DEFAULT_NODE_BORDER_COLOR;
                ctx.lineWidth = 1;
                ctx.stroke();

                ctx.fillStyle = '#000';
                ctx.font = `${Math.max(8, nodeRadius * 0.8)}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(num, x, y);
            }

            ctx.restore();
        }
function calculateCollatzSequence(startN, maxIterations, x_param, y_param, z_param) {
            let sequence = [startN];
            let current = startN;
            let steps = 0;
            let yPlusZ_operations = 0;
            let maxVal = startN;
            let minVal = startN;
            let sumVal = startN;

            let stoppingTime_t = Infinity;
            let coefficientStoppingTime_tau = Infinity;
            let paradoxicalOccurrences = [];

            const initialN = startN;

            if (x_param === 0) {
                return {
                    startN, sequence: [startN], steps: 0, maxVal: startN, minVal: startN, sumVal: startN,
                    avgVal: startN, stdDev: 0, type: "Invalid Parameters (X is 0)", converges_to_1: false,
                    stoppingTime_t: 'N/A', coefficientStoppingTime_tau: 'N/A', paradoxicalOccurrences: []
                };
            }
            if (startN === 1) {
                return {
                    startN, sequence: [1], steps: 0, maxVal: 1, minVal: 1, sumVal: 1,
                    avgVal: 1, stdDev: 0, type: "Converges to 1", converges_to_1: true,
                    stoppingTime_t: 0,
                    coefficientStoppingTime_tau: 1,
                    paradoxicalOccurrences: []
                };
            }

            while (current !== 1 && steps < maxIterations) {
                if (steps > maxIterations * 2 && maxIterations > 0) {
                     return {
                        startN, sequence: sequence, steps: steps, maxVal: maxVal, minVal: minVal, sumVal: sumVal,
                        avgVal: sumVal / sequence.length, stdDev: 0, type: "Exceeded Max Iterations (Possible Divergence)",
                        converges_to_1: false, stoppingTime_t: stoppingTime_t === Infinity ? 'N/A' : stoppingTime_t,
                        coefficientStoppingTime_tau: coefficientStoppingTime_tau === Infinity ? 'N/A' : coefficientStoppingTime_tau,
                        paradoxicalOccurrences: paradoxicalOccurrences
                    };
                }

                if (current % x_param === 0) {
                    current = current / x_param;
                } else {
                    current = (y_param * current + z_param);
                    yPlusZ_operations++;
                }

                steps++;

                if (!Number.isFinite(current) || Math.abs(current) > Number.MAX_SAFE_INTEGER || current <= 0) {
                    let errorType = "Exceeded Max Safe Integer";
                    if (current <= 0) errorType = "Reached Non-Positive Value";
                    return {
                        startN, sequence: sequence, steps: steps, maxVal: maxVal, minVal: minVal, sumVal: sumVal,
                        avgVal: sumVal / sequence.length, stdDev: 0, type: errorType,
                        converges_to_1: false, stoppingTime_t: stoppingTime_t === Infinity ? 'N/A' : stoppingTime_t,
                        coefficientStoppingTime_tau: coefficientStoppingTime_tau === Infinity ? 'N/A' : coefficientStoppingTime_tau,
                        paradoxicalOccurrences: paradoxicalOccurrences
                    };
                }

                if (sequence.includes(current)) {
                    return {
                        startN, sequence: sequence, steps: steps, maxVal: maxVal, minVal: minVal, sumVal: sumVal,
                        avgVal: sumVal / sequence.length, stdDev: 0, type: "Cycle Detected",
                        converges_to_1: false, stoppingTime_t: stoppingTime_t === Infinity ? 'N/A' : stoppingTime_t,
                        coefficientStoppingTime_tau: coefficientStoppingTime_tau === Infinity ? 'N/A' : coefficientStoppingTime_tau,
                        paradoxicalOccurrences: paradoxicalOccurrences
                    };
                }

                sequence.push(current);

                if (current > maxVal) maxVal = current;
                if (current < minVal) minVal = current;
                sumVal += current;

                const currentCoefficient = (steps === 0) ? 1 : (Math.pow(y_param, yPlusZ_operations) / Math.pow(x_param, steps));

                if (stoppingTime_t === Infinity && current < initialN) {
                    stoppingTime_t = steps;
                }

                if (coefficientStoppingTime_tau === Infinity && currentCoefficient < 1) {
                    coefficientStoppingTime_tau = steps;
                }

                if (currentCoefficient < 1 && current >= initialN) {
                    paradoxicalOccurrences.push({
                        step: steps,
                        value: current,
                        coefficient: currentCoefficient.toFixed(6)
                    });
                }
            }

            let type = "Unknown";
            let converges_to_1 = false;
            if (current === 1) {
                type = "Converges to 1";
                converges_to_1 = true;
            } else if (steps >= maxIterations) {
                type = "Max Iterations Reached";
            }

            let mean = sumVal / sequence.length;
            let sumOfSquaredDifferences = sequence.reduce((acc, val) => acc + Math.pow(val - mean, 2), 0);
            let stdDev = Math.sqrt(sumOfSquaredDifferences / sequence.length);

            return {
                startN, sequence: sequence, steps: steps, maxVal: maxVal, minVal: minVal, sumVal: sumVal,
                avgVal: mean, stdDev: stdDev, type: type, converges_to_1: converges_to_1,
                stoppingTime_t: stoppingTime_t === Infinity ? 'N/A' : stoppingTime_t,
                coefficientStoppingTime_tau: coefficientStoppingTime_tau === Infinity ? 'N/A' : coefficientStoppingTime_tau,
                paradoxicalOccurrences: paradoxicalOccurrences,
                x_param: x_param, // Ensure x_param is included in the returned data object
                y_param: y_param,
                z_param: z_param
            };
        }
        // --- REPLACE THE ENTIRE document.addEventListener SECTION BELOW WITH THIS NEW CODE ---
        document.addEventListener('DOMContentLoaded', () => {
            canvas = document.getElementById('radialViewerCanvas');
            if (canvas) {
                ctx = canvas.getContext('2d');

                // --- NEW CODE: Parse URL Parameters ---
                const urlParams = new URLSearchParams(window.location.search);

                // Get n, x, y, z from URL, providing default values
                // Use parseInt for integers, and provide a radix (10) for safety
                const n = parseInt(urlParams.get('n'), 10) || 10; // Default n to 10 if not in URL
                const x = parseInt(urlParams.get('x'), 10) || 2; // Default x to 2
                const y = parseInt(urlParams.get('y'), 10) || 3; // Default y to 3
                const z = parseInt(urlParams.get('z'), 10) || 1; // Default z to 1

                // Get modulus from URL, default to DEFAULT_MODULUS
                const modulusParam = parseInt(urlParams.get('modulus'), 10) || DEFAULT_MODULUS;
                // Ensure modulus is at least 2, as a modulus of 1 or less doesn't make sense for a circle
                const currentModulus = Math.max(2, modulusParam);

                console.log(`Parsed URL parameters: n=${n}, x=${x}, y=${y}, z=${z}, modulus=${currentModulus}`);

                // --- End NEW CODE ---
  const maxIterationsForRadial = 1000; // Define a reasonable limit for the visualization
        const collatzResult = calculateCollatzSequence(n, maxIterationsForRadial, x, y, z);

                  

        // Now, pass the *actual* Collatz sequence to render9Net
        render9Net({ sequence:  collatzResult.sequence }, currentModulus);


            } else {
                console.error("Canvas element with ID 'radialViewerCanvas' not found!");
            }
        });

    </script>
</body>
</html>