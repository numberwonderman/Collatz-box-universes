<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Radial Viewer</title>
    </head>
<body>
    <h1>Collatz Radial Viewer</h1>

    <canvas id="radialViewerCanvas" style="border: 1px solid #ccc;"></canvas>

    <script>
        // --- Global Variables for Radial Viewer ---
        // (Keep all your existing global variables here)
        let canvas;
        let ctx;
        let centerX;
        let centerY;
        let translateX = 0;
        let translateY = 0;
        let scale = 1;
        const DEFAULT_NODE_RADIUS = 10;
        const minNodeRadius = 3;
        const maxNodeRadius = 15;
        const minLineThickness = 1;
        const maxLineThickness = 4;
        const DEFAULT_NODE_COLOR = '#4CAF50';
        const DEFAULT_NODE_BORDER_COLOR = '#212121';
        const DEFAULT_LINE_COLOR = '#9E9E9E';
        const DEFAULT_MODULUS = 9;
        // --- End Global Variables ---

        // Your render9Net function (keep it as is)
        function render9Net(data, modulus = DEFAULT_MODULUS) {
            console.log("Radial Viewer: render9Net called.");
            if (!canvas) {
                canvas = document.getElementById('radialViewerCanvas');
                ctx = canvas.getContext('2d');
            }
            const pig=2; // This line is fine

            const dpi = window.devicePixelRatio || 1;
            canvas.width = canvas.offsetWidth * dpi;
            canvas.height = canvas.offsetHeight * dpi;
            ctx.scale(dpi, dpi);

            centerX = canvas.offsetWidth / 2;
            centerY = canvas.offsetHeight / 2;
            nodeRadius = DEFAULT_NODE_RADIUS;

            ctx.clearRect(0, 0, canvas.offsetWidth, canvas.offsetHeight);
            ctx.save();
            ctx.translate(centerX + translateX, centerY + translateY);
            ctx.scale(scale, scale);

            const sequence = data.sequence;
            if (sequence.length < 2) {
                if (sequence.length === 1) {
                    const num = sequence[0];
                    ctx.beginPath();
                    ctx.arc(0, 0, nodeRadius, 0, 2 * Math.PI);
                    ctx.fillStyle = DEFAULT_NODE_COLOR;
                    ctx.fill();
                    ctx.strokeStyle = DEFAULT_NODE_BORDER_COLOR;
                    ctx.lineWidth = 1;
                    ctx.stroke();

                    ctx.fillStyle = '#000';
                    ctx.font = `${Math.max(8, nodeRadius * 0.8)}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(num, 0, 0);
                }
                ctx.restore();
                return;
            }

            const normalizedLength = Math.min(sequence.length, 100);
            nodeRadius = minNodeRadius + (maxNodeRadius - minNodeRadius) * (1 - normalizedLength / 100);
            let lineThickness = minLineThickness + (maxLineThickness - minLineThickness) * (1 - normalizedLength / 100);

            for (let i = 0; i < sequence.length - 1; i++) {
                const startNum = sequence[i];
                const endNum = sequence[i + 1];

                const startAngle = (startNum % modulus) * (2 * Math.PI / modulus);
                const startRadius = 50 + startNum * 0.1;

                const endAngle = (endNum % modulus) * (2 * Math.PI / modulus);
                const endRadius = 50 + endNum * 0.1;

                const x1 = startRadius * Math.cos(startAngle);
                const y1 = startRadius * Math.sin(startAngle);
                const x2 = endRadius * Math.cos(endAngle);
                const y2 = endRadius * Math.sin(endAngle);

                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.strokeStyle = DEFAULT_LINE_COLOR;
                ctx.lineWidth = lineThickness;
                ctx.stroke();
            }

            for (let i = 0; i < sequence.length; i++) {
                const num = sequence[i];
                const angle = (num % modulus) * (2 * Math.PI / modulus);
                const radius = 50 + num * 0.1;

                const x = radius * Math.cos(angle);
                const y = radius * Math.sin(angle);

                ctx.beginPath();
                ctx.arc(x, y, nodeRadius, 0, 2 * Math.PI);
                ctx.fillStyle = DEFAULT_NODE_COLOR;
                ctx.fill();
                ctx.strokeStyle = DEFAULT_NODE_BORDER_COLOR;
                ctx.lineWidth = 1;
                ctx.stroke();

                ctx.fillStyle = '#000';
                ctx.font = `${Math.max(8, nodeRadius * 0.8)}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(num, x, y);
            }

            ctx.restore();
        }

        // --- REPLACE THE ENTIRE document.addEventListener SECTION BELOW WITH THIS NEW CODE ---
        document.addEventListener('DOMContentLoaded', () => {
            canvas = document.getElementById('radialViewerCanvas');
            if (canvas) {
                ctx = canvas.getContext('2d');

                // --- NEW CODE: Parse URL Parameters ---
                const urlParams = new URLSearchParams(window.location.search);

                // Get n, x, y, z from URL, providing default values
                // Use parseInt for integers, and provide a radix (10) for safety
                const n = parseInt(urlParams.get('n'), 10) || 10; // Default n to 10 if not in URL
                const x = parseInt(urlParams.get('x'), 10) || 2; // Default x to 2
                const y = parseInt(urlParams.get('y'), 10) || 3; // Default y to 3
                const z = parseInt(urlParams.get('z'), 10) || 1; // Default z to 1

                // Get modulus from URL, default to DEFAULT_MODULUS
                const modulusParam = parseInt(urlParams.get('modulus'), 10) || DEFAULT_MODULUS;
                // Ensure modulus is at least 2, as a modulus of 1 or less doesn't make sense for a circle
                const currentModulus = Math.max(2, modulusParam);

                console.log(`Parsed URL parameters: n=${n}, x=${x}, y=${y}, z=${z}, modulus=${currentModulus}`);

                // --- End NEW CODE ---

                // This is where you will eventually calculate the sequence and call render9Net
                // For now, let's just use some dummy data to ensure the parsing works:
                const dummySequence = [n, x, y, z, currentModulus]; // Just showing the parsed values
                render9Net({ sequence: dummySequence }, currentModulus); // Using dummy data for initial test


            } else {
                console.error("Canvas element with ID 'radialViewerCanvas' not found!");
            }
        });

    </script>
</body>
</html>