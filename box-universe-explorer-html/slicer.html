<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2D Pseudo-3D Slicer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start; /* Align to top to give space for controls */
            min-height: 100vh;
            background-color: #1a202c; /* Dark background similar to index.html */
            color: #e2e8f0; /* Light text color */
            padding: 1rem;
            box-sizing: border-box;
        }
        .container {
            background-color: #2d3748; /* Slightly lighter dark background for container */
            padding: 2rem;
            border-radius: 0.75rem; /* rounded-xl */
            box-shadow: 0 10px 15px rgba(0, 0, 0, 0.2); /* shadow-xl */
            text-align: center;
            max-width: 90%; /* Responsive width */
            margin-bottom: 2rem; /* Space below the main controls container */
        }
        /* Adjusted canvas styling for consistency across the app */
        canvas {
            display: block;
            margin: 1.5rem auto; /* mt-6 mb-6 */
            border-radius: 0.5rem; /* rounded-md */
            border: 1px solid #4a5568; /* border-gray-600 */
            max-width: 100%; /* Ensure canvas is responsive */
            height: auto; /* Maintain aspect ratio */
        }
        .param-display {
            font-size: 1.25rem; /* text-xl */
            font-weight: 600; /* font-semibold */
            margin-bottom: 1rem;
            color: #90cdf4; /* blue-300 */
        }
        .sequence-info {
            font-size: 1rem; /* text-base */
            margin-bottom: 1.5rem;
            color: #a0aec0; /* gray-400 */
        }
        .sequence-numbers {
            background-color: #1a202c; /* Darker background for sequence numbers */
            padding: 0.75rem;
            border-radius: 0.375rem; /* rounded-md */
            max-height: 8rem; /* max-h-32 */
            overflow-y: auto;
            font-size: 0.875rem; /* text-sm */
            word-break: break-all;
            color: #cbd5e0; /* gray-300 */
            margin-bottom: 1.5rem;
        }
        .color-display {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 1rem;
            margin-top: 1rem;
        }
        .color-box {
            width: 1.5rem;
            height: 1.5rem;
            border-radius: 0.25rem;
            border: 1px solid #a0aec0;
        }
        /* Styles for slideshow controls */
        .slideshow-controls {
            display: flex;
            flex-wrap: wrap;
            gap: 1rem;
            justify-content: center;
            align-items: center;
            margin-top: 1.5rem;
            padding: 1rem;
            background-color: #2d3748;
            border-radius: 0.75rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        .slideshow-controls label {
            color: #e2e8f0;
            font-weight: 600;
        }
        .slideshow-controls select,
        .slideshow-controls input[type="range"] {
            background-color: #4a5568;
            border: 1px solid #64748b;
            color: #e2e8f0;
            padding: 0.5rem;
            border-radius: 0.5rem;
        }
        .slideshow-controls button {
            padding: 0.75rem 1.5rem;
            background-color: #4299e1; /* Blue for play/stop */
            color: white;
            font-weight: bold;
            border-radius: 0.75rem;
            transition: background-color 0.3s ease;
        }
        .slideshow-controls button:hover {
            background-color: #3182ce;
        }
        /* Styles for the grid of 9-nets */
        .grid-container {
            display: grid;
            /* Calculate minmax based on desired display size, maintaining aspect ratio */
            grid-template-columns: repeat(auto-fill, minmax(180px, 1fr)); /* Adjusted for better fit */
            gap: 1.5rem;
            padding: 1rem;
            width: 100%;
            max-width: 1200px; /* Limit overall grid width */
            margin: 2rem auto;
            background-color: #2d3748;
            border-radius: 0.75rem;
            box-shadow: 0 10px 15px rgba(0, 0, 0, 0.2);
        }
        .grid-item {
            background-color: #1a202c;
            padding: 1rem;
            border-radius: 0.5rem;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            text-align: center;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: space-between; /* Distribute space */
        }
        .grid-item canvas {
            /* Set max-width to a desired display size, height auto to maintain aspect ratio */
            max-width: 150px; /* Display size for grid items */
            height: auto; /* Crucial for maintaining aspect ratio */
            margin: 0.5rem auto;
            border: 1px solid #4a5568;
        }
        .grid-item .info {
            font-size: 0.875rem;
            color: #cbd5e0;
            margin-bottom: 0.5rem;
        }
        .grid-item button {
            background-color: #61dafb; /* Light blue for "View in Main" */
            color: #1a202c;
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            font-weight: bold;
            transition: background-color 0.3s ease;
            margin-top: 0.5rem;
        }
        .grid-item button:hover {
            background-color: #21a1f1;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1 class="text-3xl font-bold mb-4">2D Pseudo-3D Slicer</h1>
        <p class="param-display" id="paramDisplay">Loading parameters...</p>
        <p class="sequence-info" id="sequenceInfo">Calculating sequence...</p>
        <!-- New element for min/max range -->
        <p class="sequence-range-info text-gray-400 text-sm mb-2" id="sequenceRangeInfo"></p>
        <!-- New element for sum -->
        <p class="sequence-sum-info text-gray-400 text-sm mb-2" id="sequenceSumInfo"></p>
        <!-- New element for average -->
        <p class="sequence-avg-info text-gray-400 text-sm mb-2" id="sequenceAvgInfo"></p>
        <!-- New element for standard deviation -->
        <p class="sequence-stddev-info text-gray-400 text-sm mb-2" id="sequenceStdDevInfo"></p>
        <div class="sequence-numbers" id="sequenceNumbers"></div>

        <!-- Single 9-net canvas (for direct URL viewing) -->
        <!-- Dimensions updated to correctly fit the 9-net drawing -->
        <canvas id="nineNetCanvas" width="380" height="290"></canvas>

        <div class="color-display">
            <span class="text-lg">Divisible:</span>
            <div id="divColorBox" class="color-box"></div>
            <span class="text-lg">Multiply/Add:</span>
            <div id="mulColorBox" class="color-box"></div>
        </div>

        <button onclick="window.close()" class="mt-6 px-6 py-3 bg-red-600 hover:bg-red-700 text-white font-bold rounded-xl shadow-lg transform transition duration-300 ease-in-out hover:scale-105 focus:outline-none focus:ring-2 focus:ring-red-400">
            Close Slicer
        </button>
    </div>

    <!-- Slideshow and Bulk Generation Controls (Moved to top for better flow) -->
    <div class="container slideshow-controls">
        <div class="flex flex-col items-center">
            <label for="animationAxis">Animate Axis:</label>
            <select id="animationAxis" class="mt-1 p-2 rounded-md">
                <option value="N">N (Start Number)</option>
                <option value="X">X (Divisor)</option>
                <option value="Y">Y (Multiplier)</option>
                <option value="Z">Z (Adder)</option>
            </select>
        </div>
        <div class="flex flex-col items-center">
            <label for="animationSpeed">Speed (ms/step):</label>
            <input type="range" id="animationSpeed" min="50" max="2000" value="500" class="mt-1">
            <span id="speedValue" class="text-sm text-gray-400">500</span>
        </div>
        <button id="toggleSlideshow" class="px-4 py-2">Play Slideshow</button>

        <div class="flex flex-col items-center">
            <label>N Range:</label>
            <div class="flex gap-2">
                <input type="number" id="nMin" value="1" min="1" class="w-20 p-2 rounded-md text-center">
                <input type="number" id="nMax" value="50" min="1" class="w-20 p-2 rounded-md text-center">
            </div>
        </div>
        <div class="flex flex-col items-center">
            <label>X Range:</label>
            <div class="flex gap-2">
                <input type="number" id="xMin" value="2" min="1" class="w-20 p-2 rounded-md text-center">
                <input type="number" id="xMax" value="5" min="1" class="w-20 p-2 rounded-md text-center">
            </div>
        </div>
        <div class="flex flex-col items-center">
            <label>Y Range:</label>
            <div class="flex gap-2">
                <input type="number" id="yMin" value="3" min="1" class="w-20 p-2 rounded-md text-center">
                <input type="number" id="yMax" value="5" min="1" class="w-20 p-2 rounded-md text-center">
            </div>
        </div>
        <div class="flex flex-col items-center">
            <label>Z Range:</label>
            <div class="flex gap-2">
                <input type="number" id="zMin" value="1" min="1" class="w-20 p-2 rounded-md text-center">
                <input type="number" id="zMax" value="5" min="1" class="w-20 p-2 rounded-md text-center">
            </div>
        </div>
        <button id="applyFilters" class="px-4 py-2 bg-green-500 hover:bg-green-600">Apply Filters</button>
    </div>

    <!-- Grid for Bulk Generated Universes -->
    <div id="gridContainer" class="grid-container">
        <!-- 9-nets will be rendered here -->
    </div>

    <script>
        // === Constants for 9-Net Dimensions ===
        // These are calculated based on the drawNineNetCanvas logic.
        // The 9-net layout is effectively 4 'face' columns wide and 3 'face' rows high.
        // Each face is 3x3 small squares.
        const FACE_SIZE = 30; // Size of each small square face
        const PADDING = 10; // Padding around the entire 9-net
        const STEP_SIZE = 3; // Number of small squares per 'face' side (3x3 grid)

        // Total internal drawing dimensions for a complete 9-net
        const NINE_NET_DRAW_WIDTH = (4 * STEP_SIZE * FACE_SIZE) + (2 * PADDING); // 4 faces horizontally * 3 squares/face * 30px/square + 2*10px padding
        const NINE_NET_DRAW_HEIGHT = (3 * STEP_SIZE * FACE_SIZE) + (2 * PADDING); // 3 faces vertically * 3 squares/face * 30px/square + 2*10px padding


        // === Generalized Collatz function ===
        // This function calculates the generalized Collatz sequence.
        // It includes error handling for X=0, cycle detection, and max iteration limit.
        // Now also calculates min, max, sum, and average values in the sequence.
        const generalizedCollatz = (num, x, y, z, maxiterations) => {
            if (x === 0) {
                return { sequence: [], type: "error", message: "X cannot be zero for the division rule." };
            }
            const output = [];
            output.push(num);
            let iterations = 0;
            const visitedNumbersMap = new Map();
            visitedNumbersMap.set(num, 0);

            let minVal = num;
            let maxVal = num;
            let sumVal = num; // Initialize sum with the starting number

            while (num !== 1 && iterations < maxiterations) {
                // --- MAX NUMBER SAFETY BARRIER ---
                // Check if the current number exceeds JavaScript's safe integer limit or becomes non-finite
                if (Math.abs(num) > Number.MAX_SAFE_INTEGER || !Number.isFinite(num)) {
                    const avgVal = sumVal / (iterations + 1);
                    // Standard Deviation calculation
                    let stdDevVal = 0;
                    if (output.length > 1) {
                        const mean = avgVal;
                        const sumOfSquaredDifferences = output.reduce((acc, val) => {
                            const diff = val - mean;
                            const squaredDiff = diff * diff;
                            if (!Number.isFinite(squaredDiff) || acc > Number.MAX_SAFE_INTEGER - squaredDiff) {
                                return Number.MAX_SAFE_INTEGER;
                            }
                            return acc + squaredDiff;
                        }, 0);

                        if (sumOfSquaredDifferences === Number.MAX_SAFE_INTEGER) {
                            stdDevVal = "Too Large";
                        } else {
                            const variance = sumOfSquaredDifferences / output.length;
                            const stdDev = Math.sqrt(variance);
                            if (!Number.isFinite(stdDev) || stdDev > Number.MAX_SAFE_INTEGER) {
                                stdDevVal = "Too Large";
                            } else {
                                stdDevVal = stdDev;
                            }
                        }
                    }
                    return { sequence: output, type: "exceeded_max_safe_integer", steps: iterations, finalNum: num, minVal: minVal, maxVal: maxVal, sumVal: sumVal, avgVal: avgVal, stdDev: stdDevVal };
                }

                let next_num;
                if (num % Math.abs(x) === 0) {
                    next_num = num / x;
                } else {
                    next_num = (Math.abs(y) || 3) * num + (z || 1);
                }

                // --- Additional robust check for next_num after calculation ---
                if (!Number.isFinite(next_num) || Math.abs(next_num) > Number.MAX_SAFE_INTEGER) {
                    const avgVal = sumVal / (iterations + 1);
                     // Standard Deviation calculation
                    let stdDevVal = 0;
                    if (output.length > 1) {
                        const mean = avgVal;
                        const sumOfSquaredDifferences = output.reduce((acc, val) => {
                            const diff = val - mean;
                            const squaredDiff = diff * diff;
                            if (!Number.isFinite(squaredDiff) || acc > Number.MAX_SAFE_INTEGER - squaredDiff) {
                                return Number.MAX_SAFE_INTEGER;
                            }
                            return acc + squaredDiff;
                        }, 0);

                        if (sumOfSquaredDifferences === Number.MAX_SAFE_INTEGER) {
                            stdDevVal = "Too Large";
                        } else {
                            const variance = sumOfSquaredDifferences / output.length;
                            const stdDev = Math.sqrt(variance);
                            if (!Number.isFinite(stdDev) || stdDev > Number.MAX_SAFE_INTEGER) {
                                stdDevVal = "Too Large";
                            } else {
                                stdDevVal = stdDev;
                            }
                        }
                    }
                    return { sequence: output, type: "exceeded_max_safe_integer", steps: iterations, finalNum: num, minVal: minVal, maxVal: maxVal, sumVal: sumVal, avgVal: avgVal, stdDev: stdDevVal };
                }


                // Update min/max values
                minVal = Math.min(minVal, next_num);
                maxVal = Math.max(maxVal, next_num);

                // Update sum, checking for potential overflow with very large numbers
                if (sumVal > Number.MAX_SAFE_INTEGER - Math.abs(next_num)) {
                    sumVal = Number.MAX_SAFE_INTEGER; // Indicate it's too large
                } else {
                    sumVal += next_num;
                }

                if (visitedNumbersMap.has(next_num)) {
                    const avgVal = sumVal / (iterations + 1);
                    // Standard Deviation calculation
                    let stdDevVal = 0;
                    if (output.length > 1) {
                        const mean = avgVal;
                        const sumOfSquaredDifferences = output.reduce((acc, val) => {
                            const diff = val - mean;
                            const squaredDiff = diff * diff;
                            if (!Number.isFinite(squaredDiff) || acc > Number.MAX_SAFE_INTEGER - squaredDiff) {
                                return Number.MAX_SAFE_INTEGER;
                            }
                            return acc + squaredDiff;
                        }, 0);

                        if (sumOfSquaredDifferences === Number.MAX_SAFE_INTEGER) {
                            stdDevVal = "Too Large";
                        } else {
                            const variance = sumOfSquaredDifferences / output.length;
                            const stdDev = Math.sqrt(variance);
                            if (!Number.isFinite(stdDev) || stdDev > Number.MAX_SAFE_INTEGER) {
                                stdDevVal = "Too Large";
                            } else {
                                stdDevVal = stdDev;
                            }
                        }
                    }

                    const cycleStartIndex = visitedNumbersMap.get(next_num);
                    const cycle = output.slice(cycleStartIndex);
                    return { sequence: output, type: "cycle", steps: iterations + 1, cycle: cycle, minVal: minVal, maxVal: maxVal, sumVal: sumVal, avgVal: avgVal, stdDev: stdDevVal };
                }
                visitedNumbersMap.set(next_num, output.length);

                num = next_num;
                output.push(num);
                iterations++;
            }

            // Calculate average and standard deviation at the end of the sequence
            const avgVal = sumVal / (iterations + 1); // +1 because output.length includes the starting number
            let stdDevVal = 0;
            if (output.length > 1) {
                const mean = avgVal;
                const sumOfSquaredDifferences = output.reduce((acc, val) => {
                    const diff = val - mean;
                    const squaredDiff = diff * diff;
                    if (!Number.isFinite(squaredDiff) || acc > Number.MAX_SAFE_INTEGER - squaredDiff) {
                        return Number.MAX_SAFE_INTEGER;
                    }
                    return acc + squaredDiff;
                }, 0);

                if (sumOfSquaredDifferences === Number.MAX_SAFE_INTEGER) {
                    stdDevVal = "Too Large";
                } else {
                    const variance = sumOfSquaredDifferences / output.length;
                    const stdDev = Math.sqrt(variance);
                    if (!Number.isFinite(stdDev) || stdDev > Number.MAX_SAFE_INTEGER) {
                        stdDevVal = "Too Large";
                    } else {
                        stdDevVal = stdDev;
                    }
                }
            }

            if (num === 1) {
                return { sequence: output, type: "converges_to_1", steps: iterations, minVal: minVal, maxVal: maxVal, sumVal: sumVal, avgVal: avgVal, stdDev: stdDevVal };
            } else {
                return { sequence: output, type: "reached_max_iterations", steps: iterations, finalNum: num, minVal: minVal, maxVal: maxVal, sumVal: sumVal, avgVal: avgVal, stdDev: stdDevVal };
            }
        };

        // === drawNineNetCanvas function ===
        /**
         * Draws the 9-net visualization of the sequence on a canvas.
         * @param {HTMLCanvasElement} canvas - The canvas element to draw on.
         * @param {Array<number>} sequence - The sequence of numbers to visualize.
         * @param {number} xVal - The X parameter used in the Collatz rule for color determination.
         * @param {string} divColor - Color for divisible numbers.
         * @param {string} mulColor - Color for multiply/add numbers.
         */
        function drawNineNetCanvas(canvas, sequence, xVal, divColor, mulColor) {
            const ctx = canvas.getContext("2d");
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Use the global constants for drawing logic
            const faceSize = FACE_SIZE;
            const padding = PADDING;
            const stepSize = STEP_SIZE;

            // Define the layout of the 9-net (a 3x3 grid of 3x3 faces)
            const layout = [
                { r: 0, c: 1 }, // Top
                { r: 1, c: 0 }, // Left
                { r: 1, c: 1 }, // Center-Left (main sequence starts here)
                { r: 1, c: 2 }, // Center
                { r: 1, c: 3 }, // Center-Right
                { r: 2, c: 1 }  // Bottom
            ];

            let sequenceIndex = 0; // Tracks the current position in the Collatz sequence

            // Iterate through each 'face' in the predefined layout
            for (const pos of layout) {
                // Iterate through the 3x3 grid of small squares within each face
                for (let i = 0; i < stepSize; i++) { // Row within the face
                    for (let j = 0; j < stepSize; j++) { // Column within the face
                        // Calculate the x and y coordinates for the current small square
                        const x = padding + (pos.c * stepSize + j) * faceSize;
                        const y = padding + (pos.r * stepSize + i) * faceSize;

                        let color = "#444"; // Default color for squares not representing a sequence number
                        let label = ""; // Optional label for the number

                        // Check if there's a corresponding number in the sequence
                        if (sequenceIndex < sequence.length) {
                            const val = sequence[sequenceIndex];
                            // Determine color based on the Collatz rule (divisible by X or not)
                            if (val % Math.abs(xVal) === 0) {
                                color = divColor; // Green if divisible
                            } else {
                                color = mulColor; // Orange if not divisible
                            }
                            label = val.toString(); // Set label to the number itself

                            // Ellipsis Logic for very large numbers
                            const maxChars = 5;
                            if (label.length > maxChars) {
                                const start = label.substring(0, Math.ceil((maxChars - 3) / 2));
                                const end = label.substring(label.length - Math.floor((maxChars - 3) / 2));
                                label = start + "..." + end;
                            }
                        }

                        // Draw the square
                        ctx.fillStyle = color;
                        ctx.fillRect(x, y, faceSize - 2, faceSize - 2); // -2 for spacing between squares

                        // Draw the number label if available
                        if (label) {
                            ctx.fillStyle = "#FFF"; // White text
                            // Dynamic font sizing
                            let currentFontSize = 10;
                            if (label.length > 7) {
                                currentFontSize = 6;
                            } else if (label.length > 5) {
                                currentFontSize = 8;
                            }
                            ctx.font = `${currentFontSize}px Arial`;
                            ctx.textAlign = "center";
                            ctx.textBaseline = "middle";
                            ctx.fillText(label, x + faceSize / 2 - 1, y + faceSize / 2 - 1); // Center text
                        }

                        sequenceIndex++; // Move to the next number in the sequence
                    }
                }
            }
        }

        // Function to parse URL parameters
        function getUrlParams() {
            const params = {};
            window.location.search.substring(1).split('&').forEach(param => {
                const parts = param.split('=');
                if (parts.length === 2) {
                    params[parts[0]] = decodeURIComponent(parts[1]);
                }
            });
            return params;
        }

        // Global variables for colors (can be overridden by URL params)
        let divColor = "#34d399"; // Default Green
        let mulColor = "#fb923c"; // Default Orange

        // Slideshow Animation Logic
        let slideshowInterval;
        let isSlideshowPlaying = false;
        let currentAnimationValue;
        let allBoxUniverses = []; // Stores all generated universes for bulk display/slideshow
        let filteredBoxUniverses = []; // Currently displayed universes (if filtering was applied)
        const MAX_ITERATIONS = 1000; // Max iterations for sequence calculation

        // Get elements for controls
        const animationAxisSelect = document.getElementById('animationAxis');
        const animationSpeedSlider = document.getElementById('animationSpeed');
        const speedValueSpan = document.getElementById('speedValue');
        const toggleSlideshowButton = document.getElementById('toggleSlideshow');
        const nMinInput = document.getElementById('nMin');
        const nMaxInput = document.getElementById('nMax');
        const xMinInput = document.getElementById('xMin');
        const xMaxInput = document.getElementById('xMax');
        const yMinInput = document.getElementById('yMin');
        const yMaxInput = document.getElementById('yMax');
        const zMinInput = document.getElementById('zMin');
        const zMaxInput = document.getElementById('zMax');
        const applyFiltersButton = document.getElementById('applyFilters');
        const gridContainer = document.getElementById('gridContainer');
        const sequenceRangeInfo = document.getElementById('sequenceRangeInfo'); // New element for main slicer display
        const sequenceSumInfo = document.getElementById('sequenceSumInfo'); // New element for main slicer display
        const sequenceAvgInfo = document.getElementById('sequenceAvgInfo'); // New element for main slicer display
        const sequenceStdDevInfo = document.getElementById('sequenceStdDevInfo'); // New element for main slicer display


        // Update speed value display
        animationSpeedSlider.addEventListener('input', () => {
            speedValueSpan.textContent = animationSpeedSlider.value;
        });

        toggleSlideshowButton.addEventListener('click', () => {
            if (isSlideshowPlaying) {
                clearInterval(slideshowInterval);
                toggleSlideshowButton.textContent = 'Play Slideshow';
                isSlideshowPlaying = false;
            } else {
                toggleSlideshowButton.textContent = 'Stop Slideshow';
                isSlideshowPlaying = true;
                
                const axis = animationAxisSelect.value;
                if (axis === 'N') {
                    currentAnimationValue = parseInt(nMinInput.value);
                } else if (axis === 'X') {
                    currentAnimationValue = parseInt(xMinInput.value);
                } else if (axis === 'Y') {
                    currentAnimationValue = parseInt(yMinInput.value);
                } else if (axis === 'Z') {
                    currentAnimationValue = parseInt(zMinInput.value);
                } else {
                    currentAnimationValue = 0; // Fallback
                }

                animationStep(); // Call the animation step immediately to draw the first frame
                slideshowInterval = setInterval(animationStep, parseInt(animationSpeedSlider.value));
            }
        });

        // Function to perform one step of the animation
        function animationStep() {
            const axis = animationAxisSelect.value;
            let minVal, maxVal, inputElement;

            if (axis === 'N') {
                minVal = parseInt(nMinInput.value);
                maxVal = parseInt(nMaxInput.value);
                inputElement = nMinInput;
            } else if (axis === 'X') {
                minVal = parseInt(xMinInput.value);
                maxVal = parseInt(xMaxInput.value);
                inputElement = xMinInput;
            } else if (axis === 'Y') {
                minVal = parseInt(yMinInput.value);
                maxVal = parseInt(yMaxInput.value);
                inputElement = yMinInput;
            } else if (axis === 'Z') {
                minVal = parseInt(zMinInput.value);
                maxVal = parseInt(zMaxInput.value);
                inputElement = zMinInput;
            }

            currentAnimationValue++;

            if (currentAnimationValue > maxVal) {
                currentAnimationValue = minVal;
            }

            inputElement.value = currentAnimationValue;
            applyAndDrawFilters(); // Re-apply filters and redraw the canvas with the new parameter
        }

        // Function to generate a set of Box Universes based on specified ranges
        function generateBoxUniverses(nMin, nMax, xMin, xMax, yMin, yMax, zMin, zMax) {
            const tempUniverses = [];
            const maxUniversesToGenerate = 100; // Limit to prevent performance issues
            let generatedCount = 0;

            for (let n = nMin; n <= nMax && generatedCount < maxUniversesToGenerate; n++) {
                for (let x = xMin; x <= xMax && generatedCount < maxUniversesToGenerate; x++) {
                    if (x === 0) continue; 
                    for (let y = yMin; y <= yMax && generatedCount < maxUniversesToGenerate; y++) {
                        for (let z = zMin; z <= zMax && generatedCount < maxUniversesToGenerate; z++) {
                            const result = generalizedCollatz(n, x, y, z, MAX_ITERATIONS);
                            if (result.type !== "error") {
                                tempUniverses.push({
                                    N: n, X: x, Y: y, Z: z,
                                    sequence: result.sequence,
                                    steps: result.steps,
                                    type: result.type,
                                    minVal: result.minVal, // min value in sequence
                                    maxVal: result.maxVal,  // max value in sequence
                                    sumVal: result.sumVal,   // sum of sequence values
                                    avgVal: result.avgVal,    // average of sequence values
                                    stdDev: result.stdDev     // standard deviation of sequence values
                                });
                                generatedCount++;
                            }
                        }
                    }
                }
            }
            return tempUniverses;
        }

        // Function to get current filter values from inputs
        function getFilterValues() {
            return {
                nMin: parseInt(nMinInput.value) || 1,
                nMax: parseInt(nMaxInput.value) || Infinity,
                xMin: parseInt(xMinInput.value) || 1,
                xMax: parseInt(xMaxInput.value) || Infinity,
                yMin: parseInt(yMinInput.value) || 1,
                yMax: parseInt(yMaxInput.value) || Infinity,
                zMin: parseInt(zMinInput.value) || 1,
                zMax: parseInt(zMaxInput.value) || Infinity
            };
        }

        // Function to get current filter values from inputs and apply them
        function applyAndDrawFilters() {
            const filters = getFilterValues();
            allBoxUniverses = generateBoxUniverses(
                filters.nMin, filters.nMax,
                filters.xMin, filters.xMax,
                filters.yMin, filters.yMax,
                filters.zMin, filters.zMax
            );
            filteredBoxUniverses = allBoxUniverses; // For now, no further filtering
            drawAllBoxUniverses();
        }

        // --- DRAWING FUNCTION FOR BULK UNIVERSES ---
        function drawAllBoxUniverses() {
            gridContainer.innerHTML = ''; // Clear previous grid items

            filteredBoxUniverses.forEach((bu) => {
                const gridItemDiv = document.createElement('div');
                gridItemDiv.className = 'grid-item';

                const canvasElement = document.createElement('canvas');
                // Set internal canvas resolution to the correct 9-net drawing size
                canvasElement.width = NINE_NET_DRAW_WIDTH;
                canvasElement.height = NINE_NET_DRAW_HEIGHT;
                gridItemDiv.appendChild(canvasElement);

                drawNineNetCanvas(canvasElement, bu.sequence, bu.X, divColor, mulColor);

                const infoDiv = document.createElement('div');
                infoDiv.className = 'info';
                infoDiv.innerHTML = `N=${bu.N}, X=${bu.X}, Y=${bu.Y}, Z=${bu.Z}<br>Steps: ${bu.steps}, Type: ${bu.type.replace(/_/g, ' ')}<br>Range: ${bu.minVal.toLocaleString()} to ${bu.maxVal.toLocaleString()}<br>Sum: ${typeof bu.sumVal === 'number' ? bu.sumVal.toLocaleString() : bu.sumVal}<br>Average: ${typeof bu.avgVal === 'number' ? bu.avgVal.toLocaleString(undefined, { maximumFractionDigits: 2 }) : bu.avgVal}<br>Std Dev: ${typeof bu.stdDev === 'number' ? bu.stdDev.toLocaleString(undefined, { maximumFractionDigits: 2 }) : bu.stdDev}`;
                gridItemDiv.appendChild(infoDiv);

                // Add "View in Main Explorer" button
                const viewInMainBtn = document.createElement('button');
                viewInMainBtn.textContent = 'View in Main Explorer';
                viewInMainBtn.addEventListener('click', () => {
                    const url = `index.html?n=${bu.N}&x=${bu.X}&y=${bu.Y}&z=${bu.Z}`;
                    window.open(url, '_blank'); // Open index.html in a new tab with parameters
                });
                gridItemDiv.appendChild(viewInMainBtn);

                gridContainer.appendChild(gridItemDiv);
            });

            if (filteredBoxUniverses.length === 0) {
                const noResults = document.createElement('p');
                noResults.className = 'text-center text-gray-400 p-4';
                noResults.textContent = 'No Box Universes found for the current filter.';
                gridContainer.appendChild(noResults);
            }
        }

        // Main logic for slicer.html
        document.addEventListener('DOMContentLoaded', () => {
            const params = getUrlParams();
            const n = parseInt(params.n);
            const x = parseInt(params.x);
            const y = parseInt(params.y);
            const z = parseInt(params.z);
            const urlDivColor = params.divColor;
            const urlMulColor = params.mulColor;

            // Apply colors from URL if present
            if (urlDivColor) divColor = urlDivColor;
            if (urlMulColor) mulColor = urlMulColor;

            const paramDisplay = document.getElementById('paramDisplay');
            const sequenceInfo = document.getElementById('sequenceInfo');
            const sequenceNumbersDiv = document.getElementById('sequenceNumbers');
            const nineNetCanvas = document.getElementById('nineNetCanvas'); // This is the main single canvas at the top
            const divColorBox = document.getElementById('divColorBox');
            const mulColorBox = document.getElementById('mulColorBox');
            const sequenceRangeInfo = document.getElementById('sequenceRangeInfo');
            const sequenceSumInfo = document.getElementById('sequenceSumInfo');
            const sequenceAvgInfo = document.getElementById('sequenceAvgInfo');
            const sequenceStdDevInfo = document.getElementById('sequenceStdDevInfo');


            // Set color boxes
            divColorBox.style.backgroundColor = divColor;
            mulColorBox.style.backgroundColor = mulColor;

            if (!isNaN(n) && !isNaN(x) && !isNaN(y) && !isNaN(z)) {
                paramDisplay.textContent = `N=${n}, X=${x}, Y=${y}, Z=${z}`;
                const result = generalizedCollatz(n, x, y, z, MAX_ITERATIONS);

                if (result.type === "error") {
                    sequenceInfo.textContent = `Error: ${result.message}`;
                    sequenceNumbersDiv.textContent = '';
                    sequenceRangeInfo.textContent = '';
                    sequenceSumInfo.textContent = '';
                    sequenceAvgInfo.textContent = '';
                    sequenceStdDevInfo.textContent = '';
                    nineNetCanvas.style.display = 'none';
                } else {
                    let typeText = result.type.replace(/_/g, ' ');
                    if (result.type === "reached_max_iterations") {
                        typeText += ` - Ended at ${result.finalNum}`;
                    } else if (result.type === "exceeded_max_safe_integer") {
                        typeText += ` - Ended at ${result.finalNum} (Exceeded safe integer limit or became infinite)`;
                    } else if (result.type === "cycle") {
                        typeText += ` - Cycle: ${result.cycle.join(' → ')}`;
                    }
                    sequenceInfo.textContent = `Steps: ${result.steps} (Type: ${typeText})`;
                    sequenceNumbersDiv.textContent = Array.isArray(result.sequence) ? result.sequence.join(' → ') : 'Invalid sequence data';
                    sequenceRangeInfo.textContent = `Range: ${result.minVal.toLocaleString()} to ${result.maxVal.toLocaleString()}`;
                    sequenceSumInfo.textContent = `Sum: ${typeof result.sumVal === 'number' ? result.sumVal.toLocaleString() : result.sumVal}`;
                    sequenceAvgInfo.textContent = `Average: ${typeof result.avgVal === 'number' ? result.avgVal.toLocaleString(undefined, { maximumFractionDigits: 2 }) : result.avgVal}`;
                    sequenceStdDevInfo.textContent = `Standard Deviation: ${typeof result.stdDev === 'number' ? result.stdDev.toLocaleString(undefined, { maximumFractionDigits: 2 }) : result.stdDev}`;
                    drawNineNetCanvas(nineNetCanvas, result.sequence, x, divColor, mulColor);
                    nineNetCanvas.style.display = 'block'; // Ensure it's visible
                }
            } else {
                paramDisplay.textContent = 'No specific sequence loaded. Use controls below.';
                sequenceInfo.textContent = '';
                sequenceNumbersDiv.textContent = '';
                sequenceRangeInfo.textContent = '';
                sequenceSumInfo.textContent = '';
                sequenceAvgInfo.textContent = '';
                sequenceStdDevInfo.textContent = '';
                nineNetCanvas.style.display = 'none'; // Hide single canvas if no params
            }

            // Event listener for apply filters button
            applyFiltersButton.addEventListener('click', applyAndDrawFilters);

            // Initial draw of bulk universes (always happens regardless of URL params)
            applyAndDrawFilters(); // This will populate the grid with default ranges if no specific sequence was loaded

            // Adjust canvas size if needed for responsiveness (for the single canvas at the top)
            function resizeMainCanvas() {
                const containerWidth = nineNetCanvas.parentElement.clientWidth;
                const desiredDisplayWidth = Math.min(containerWidth * 0.9, NINE_NET_DRAW_WIDTH);
                nineNetCanvas.style.width = `${desiredDisplayWidth}px`;
                nineNetCanvas.style.height = 'auto'; // Important for aspect ratio
                // Redraw only if a sequence was loaded via URL
                if (!isNaN(n) && !isNaN(x) && !isNaN(y) && !isNaN(z)) {
                    const result = generalizedCollatz(n, x, y, z, MAX_ITERATIONS);
                    if (result.type !== "error") {
                        drawNineNetCanvas(nineNetCanvas, result.sequence, x, divColor, mulColor);
                    }
                }
            }
            window.addEventListener('resize', resizeMainCanvas);
            resizeMainCanvas(); // Initial resize
        });
    </script>
</body>
</html>
