<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2D Pseudo-3D Slicer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start; /* Align to top to give space for controls */
            min-height: 100vh;
            background-color: #1a202c; /* Dark background similar to index.html */
            color: #e2e8f0; /* Light text color */
            padding: 1rem;
            box-sizing: border-box;
        }
        .container {
            background-color: #2d3748; /* Slightly lighter dark background for container */
            padding: 2rem;
            border-radius: 0.75rem; /* rounded-xl */
            box-shadow: 0 10px 15px rgba(0, 0, 0, 0.2); /* shadow-xl */
            text-align: center;
            max-width: 90%; /* Responsive width */
            margin-bottom: 2rem;
            width: 100%; /* Ensure it takes full width up to max-width */
        }
        /* Adjusted canvas styling for consistency across the app */
        canvas {
            display: block;
            margin: 1.5rem auto; /* mt-6 mb-6 */
            border-radius: 0.5rem; /* rounded-md */
            border: 1px solid #4a5568; /* border-gray-600 */
            max-width: 100%; /* Ensure canvas is responsive */
            height: auto; /* Maintain aspect ratio */
        }
        .param-display {
            font-size: 1.25rem; /* text-xl */
            font-weight: 600; /* font-semibold */
            margin-bottom: 1rem;
            color: #90cdf4; /* blue-300 */
        }
        .sequence-info {
            font-size: 1rem; /* text-base */
            margin-bottom: 1.5rem;
            color: #a0aec0; /* gray-400 */
        }
        .sequence-numbers {
            background-color: #1a202c; /* Darker background for sequence numbers */
            padding: 0.75rem;
            border-radius: 0.375rem; /* rounded-md */
            max-height: 8rem; /* max-h-32 */
            overflow-y: auto;
            font-size: 0.875rem; /* text-sm */
            word-break: break-all;
            color: #cbd5e0; /* gray-300 */
            margin-bottom: 1.5rem;
        }
        .color-display {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 1rem;
            margin-top: 1rem;
        }
        .color-box {
            width: 1.5rem;
            height: 1.5rem;
            border-radius: 0.25rem;
            border: 1px solid #a0aec0;
        }
        /* Styles for slideshow controls */
        .slideshow-controls {
            display: flex;
            flex-wrap: wrap;
            gap: 1rem;
            justify-content: center;
            align-items: center;
            margin-top: 1.5rem;
            padding: 1rem;
            background-color: #2d3748;
            border-radius: 0.75rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        .slideshow-controls label {
            color: #e2e8f0;
            font-weight: 600;
        }
        .slideshow-controls select,
        .slideshow-controls input[type="range"],
        .slideshow-controls input[type="number"] { /* Added number input styling */
            background-color: #4a5568;
            border: 1px solid #64748b;
            color: #e2e8f0;
            padding: 0.5rem;
            border-radius: 0.5rem;
        }
        .slideshow-controls button {
            padding: 0.75rem 1.5rem;
            background-color: #4299e1; /* Blue for play/stop */
            color: white;
            font-weight: bold;
            border-radius: 0.75rem;
            transition: background-color 0.3s ease;
        }
        .slideshow-controls button:hover {
            background-color: #3182ce;
        }
        /* Styles for the grid of 9-nets */
        .grid-container {
            display: grid;
            /* Calculate minmax based on desired display size, maintaining aspect ratio */
            grid-template-columns: repeat(auto-fill, minmax(180px, 1fr)); /* Adjusted for better fit */
            gap: 1.5rem;
            padding: 1rem;
            width: 100%;
            max-width: 1200px; /* Limit overall grid width */
            margin: 2rem auto;
            background-color: #2d3748;
            border-radius: 0.75rem;
            box-shadow: 0 10px 15px rgba(0, 0, 0, 0.2);
        }
        .grid-item {
            background-color: #1a202c;
            padding: 1rem;
            border-radius: 0.5rem;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            text-align: center;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: space-between; /* Distribute space */
        }
        .grid-item canvas {
            /* Set max-width to a desired display size, height auto to maintain aspect ratio */
            max-width: 150px; /* Display size for grid items */
            height: auto; /* Crucial for maintaining aspect ratio */
            margin: 0.5rem auto;
            border: 1px solid #4a5568;
        }
        .grid-item .info {
            font-size: 0.875rem;
            color: #cbd5e0;
            margin-bottom: 0.5rem;
        }
        .grid-item button {
            background-color: #61dafb; /* Light blue for "View in Main" */
            color: #1a202c;
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            font-weight: bold;
            transition: background-color 0.3s ease;
            margin-top: 0.5rem;
        }
        .grid-item button:hover {
            background-color: #21a1f1;
        }
        /* Custom styling for the gold star/indicator */
        .gold-star {
            color: gold; /* Or use an emoji like '⭐' in the HTML directly */
            font-size: 1.25rem; /* text-xl */
            margin-left: 0.25rem; /* ml-1 */
            display: inline-block; /* To align with text */
        }
    </style>
</head>
<body>
    <div class="container">
        <h1 class="text-3xl font-bold mb-4">2D Pseudo-3D Slicer</h1>
        <p class="param-display" id="paramDisplay">Loading parameters...</p>
        <p class="sequence-info" id="sequenceInfo">Calculating sequence...</p>
        <!-- New element for min/max range -->
        <p class="sequence-range-info text-gray-400 text-sm mb-2" id="sequenceRangeInfo"></p>
        <!-- New element for sum -->
        <p class="sequence-sum-info text-gray-400 text-sm mb-2" id="sequenceSumInfo"></p>
        <!-- New element for average -->
        <p class="sequence-avg-info text-gray-400 text-sm mb-2" id="sequenceAvgInfo"></p>
        <!-- New element for standard deviation -->
        <p class="sequence-stddev-info text-gray-400 text-sm mb-2" id="sequenceStdDevInfo"></p>
        <div class="sequence-numbers" id="sequenceNumbers"></div>

        <!-- Single 9-net canvas (for direct URL viewing) -->
        <!-- Dimensions updated to correctly fit the 9-net drawing -->
        <canvas id="nineNetCanvas" width="380" height="290"></canvas>

        <div class="color-display">
            <span class="text-lg">Divisible:</span>
            <div id="divColorBox" class="color-box"></div>
            <span class="text-lg">Multiply/Add:</span>
            <div id="mulColorBox" class="color-box"></div>
        </div>

        <button onclick="window.close()" class="mt-6 px-6 py-3 bg-red-600 hover:bg-red-700 text-white font-bold rounded-xl shadow-lg transform transition duration-300 ease-in-out hover:scale-105 focus:outline-none focus:ring-2 focus:ring-red-400">
            Close Slicer
        </button>
    </div>

    <!-- Slideshow and Bulk Generation Controls (Moved to top for better flow) -->
    <div class="container slideshow-controls">
        <div class="flex flex-col items-center">
            <label for="animationAxis">Animate Axis:</label>
            <select id="animationAxis" class="mt-1 p-2 rounded-md">
                <option value="N">N (Start Number)</option>
                <option value="X">X (Divisor)</option>
                <option value="Y">Y (Multiplier)</option>
                <option value="Z">Z (Adder)</option>
            </select>
        </div>
        <div class="flex flex-col items-center">
            <label for="animationSpeed">Speed (ms/step):</label>
            <input type="range" id="animationSpeed" min="50" max="2000" value="500" class="mt-1">
            <span id="speedValue" class="text-sm text-gray-400">500</span>
        </div>
        <button id="toggleSlideshow" class="px-4 py-2">Play Slideshow</button>

        <div class="flex flex-col items-center">
            <label class="flex items-center gap-2">N Range:
                <span id="n-star" class="gold-star hidden">⭐</span>
            </label>
            <div class="flex gap-2">
                <input type="number" id="nMin" value="1" min="1" class="w-20 p-2 rounded-md text-center">
                <input type="number" id="nMax" value="50" min="1" class="w-20 p-2 rounded-md text-center">
            </div>
        </div>
        <div class="flex flex-col items-center">
            <label class="flex items-center gap-2">X Range:
                <span id="x-star" class="gold-star hidden">⭐</span>
            </label>
            <div class="flex gap-2">
                <input type="number" id="xMin" value="2" min="1" class="w-20 p-2 rounded-md text-center">
                <input type="number" id="xMax" value="5" min="1" class="w-20 p-2 rounded-md text-center">
            </div>
        </div>
        <div class="flex flex-col items-center">
            <label class="flex items-center gap-2">Y Range:
                <span id="y-star" class="gold-star hidden">⭐</span>
            </label>
            <div class="flex gap-2">
                <input type="number" id="yMin" value="3" min="1" class="w-20 p-2 rounded-md text-center">
                <input type="number" id="yMax" value="5" min="1" class="w-20 p-2 rounded-md text-center">
            </div>
        </div>
        <div class="flex flex-col items-center">
            <label class="flex items-center gap-2">Z Range:
                <span id="z-star" class="gold-star hidden">⭐</span>
            </label>
            <div class="flex gap-2">
                <input type="number" id="zMin" value="1" min="1" class="w-20 p-2 rounded-md text-center">
                <input type="number" id="zMax" value="5" min="1" class="w-20 p-2 rounded-md text-center">
            </div>
        </div>
        <button id="applyFilters" class="px-4 py-2 bg-green-500 hover:bg-green-600">Apply Filters</button>
    </div>

    <!-- Grid for Bulk Generated Universes -->
    <div id="gridContainer" class="grid-container">
        <!-- 9-nets will be rendered here -->
    </div>

    <script>
        // === Constants for 9-Net Dimensions ===
        // These are calculated based on the drawNineNetCanvas logic.
        // The 9-net layout is effectively 4 'face' columns wide and 3 'face' rows high.
        // Each face is 3x3 small squares.
        const FACE_SIZE = 30; // Size of each small square face
        const PADDING = 10; // Padding around the entire 9-net
        const STEP_SIZE = 3; // Number of small squares per 'face' side (3x3 grid)

        // Total internal drawing dimensions for a complete 9-net
        const NINE_NET_DRAW_WIDTH = (4 * STEP_SIZE * FACE_SIZE) + (2 * PADDING); // 4 faces horizontally * 3 squares/face * 30px/square + 2*10px padding
        const NINE_NET_DRAW_HEIGHT = (3 * STEP_SIZE * FACE_SIZE) + (2 * PADDING); // 3 faces vertically * 3 squares/face * 30px/square + 2*10px padding


        // === Generalized Collatz function ===
        // This function calculates the generalized Collatz sequence.
        // It includes error handling for X=0, cycle detection, and max iteration limit.
        // Now also calculates min, max, sum, and average values in the sequence.
        const generalizedCollatz = (num, x, y, z, maxiterations) => {
            if (x === 0) {
                return { sequence: [], type: "error", message: "X cannot be zero for the division rule." };
            }
            const output = [];
            output.push(num);
            let iterations = 0;
            const visitedNumbersMap = new Map();
            visitedNumbersMap.set(num, 0);

            let minVal = num;
            let maxVal = num;
            let sumVal = num; // Initialize sum with the starting number

            while (num !== 1 && iterations < maxiterations) {
                // --- MAX NUMBER SAFETY BARRIER ---
                // Check if the current number exceeds JavaScript's safe integer limit or becomes non-finite
                if (Math.abs(num) > Number.MAX_SAFE_INTEGER || !Number.isFinite(num)) {
                    const avgVal = sumVal / (iterations + 1);
                    // Standard Deviation calculation
                    let stdDevVal = 0;
                    if (output.length > 1) {
                        const mean = avgVal;
                        const sumOfSquaredDifferences = output.reduce((acc, val) => {
                            const diff = val - mean;
                            const squaredDiff = diff * diff;
                            if (!Number.isFinite(squaredDiff) || acc > Number.MAX_SAFE_INTEGER - squaredDiff) {
                                return Number.MAX_SAFE_INTEGER;
                            }
                            return acc + squaredDiff;
                        }, 0);

                        if (sumOfSquaredDifferences === Number.MAX_SAFE_INTEGER) {
                            stdDevVal = "Too Large";
                        } else {
                            const variance = sumOfSquaredDifferences / output.length;
                            const stdDev = Math.sqrt(variance);
                            if (!Number.isFinite(stdDev) || stdDev > Number.MAX_SAFE_INTEGER) {
                                stdDevVal = "Too Large";
                            } else {
                                stdDevVal = stdDev;
                            }
                        }
                    }
                    return { sequence: output, type: "exceeded_max_safe_integer", steps: iterations, finalNum: num, minVal: minVal, maxVal: maxVal, sumVal: sumVal, avgVal: avgVal, stdDev: stdDevVal };
                }

                let next_num;
                if (num % Math.abs(x) === 0) {
                    next_num = num / x;
                } else {
                    next_num = (Math.abs(y) || 3) * num + (z || 1);
                }

                // --- Additional robust check for next_num after calculation ---
                if (!Number.isFinite(next_num) || Math.abs(next_num) > Number.MAX_SAFE_INTEGER) {
                    const avgVal = sumVal / (iterations + 1);
                       // Standard Deviation calculation
                    let stdDevVal = 0;
                    if (output.length > 1) {
                        const mean = avgVal;
                        const sumOfSquaredDifferences = output.reduce((acc, val) => {
                            const diff = val - mean;
                            const squaredDiff = diff * diff;
                            if (!Number.isFinite(squaredDiff) || acc > Number.MAX_SAFE_INTEGER - squaredDiff) {
                                return Number.MAX_SAFE_INTEGER;
                            }
                            return acc + squaredDiff;
                        }, 0);

                        if (sumOfSquaredDifferences === Number.MAX_SAFE_INTEGER) {
                            stdDevVal = "Too Large";
                        } else {
                            const variance = sumOfSquaredDifferences / output.length;
                            const stdDev = Math.sqrt(variance);
                            if (!Number.isFinite(stdDev) || stdDev > Number.MAX_SAFE_INTEGER) {
                                stdDevVal = "Too Large";
                            } else {
                                stdDevVal = stdDev;
                            }
                        }
                    }
                    return { sequence: output, type: "exceeded_max_safe_integer", steps: iterations, finalNum: num, minVal: minVal, maxVal: maxVal, sumVal: sumVal, avgVal: avgVal, stdDev: stdDevVal };
                }


                // Update min/max values
                minVal = Math.min(minVal, next_num);
                maxVal = Math.max(maxVal, next_num);

                // Update sum, checking for potential overflow with very large numbers
                if (sumVal > Number.MAX_SAFE_INTEGER - Math.abs(next_num)) {
                    sumVal = Number.MAX_SAFE_INTEGER; // Indicate it's too large
                } else {
                    sumVal += next_num;
                }

                if (visitedNumbersMap.has(next_num)) {
                    const avgVal = sumVal / (iterations + 1);
                    // Standard Deviation calculation
                    let stdDevVal = 0;
                    if (output.length > 1) {
                        const mean = avgVal;
                        const sumOfSquaredDifferences = output.reduce((acc, val) => {
                            const diff = val - mean;
                            const squaredDiff = diff * diff;
                            if (!Number.isFinite(squaredDiff) || acc > Number.MAX_SAFE_INTEGER - squaredDiff) {
                                return Number.MAX_SAFE_INTEGER;
                            }
                            return acc + squaredDiff;
                        }, 0);

                        if (sumOfSquaredDifferences === Number.MAX_SAFE_INTEGER) {
                            stdDevVal = "Too Large";
                        } else {
                            const variance = sumOfSquaredDifferences / output.length;
                            const stdDev = Math.sqrt(variance);
                            if (!Number.isFinite(stdDev) || stdDev > Number.MAX_SAFE_INTEGER) {
                                stdDevVal = "Too Large";
                            } else {
                                stdDevVal = stdDev;
                            }
                        }
                    }

                    const cycleStartIndex = visitedNumbersMap.get(next_num);
                    const cycle = output.slice(cycleStartIndex);
                    return { sequence: output, type: "cycle", steps: iterations + 1, cycle: cycle, minVal: minVal, maxVal: maxVal, sumVal: sumVal, avgVal: avgVal, stdDev: stdDevVal };
                }
                visitedNumbersMap.set(next_num, output.length);

                num = next_num;
                output.push(num);
                iterations++;
            }

            // Calculate average and standard deviation at the end of the sequence
            const avgVal = sumVal / (iterations + 1); // +1 because output.length includes the starting number
            let stdDevVal = 0;
            if (output.length > 1) {
                const mean = avgVal;
                const sumOfSquaredDifferences = output.reduce((acc, val) => {
                    const diff = val - mean;
                    const squaredDiff = diff * diff;
                    if (!Number.isFinite(squaredDiff) || acc > Number.MAX_SAFE_INTEGER - squaredDiff) {
                        return Number.MAX_SAFE_INTEGER;
                    }
                    return acc + squaredDiff;
                }, 0);

                if (sumOfSquaredDifferences === Number.MAX_SAFE_INTEGER) {
                    stdDevVal = "Too Large";
                } else {
                    const variance = sumOfSquaredDifferences / output.length;
                    const stdDev = Math.sqrt(variance);
                    if (!Number.isFinite(stdDev) || stdDev > Number.MAX_SAFE_INTEGER) {
                        stdDevVal = "Too Large";
                    } else {
                        stdDevVal = stdDev;
                    }
                }
            }

            if (num === 1) {
                return { sequence: output, type: "converges_to_1", steps: iterations, minVal: minVal, maxVal: maxVal, sumVal: sumVal, avgVal: avgVal, stdDev: stdDevVal };
            } else {
                return { sequence: output, type: "reached_max_iterations", steps: iterations, finalNum: num, minVal: minVal, maxVal: maxVal, sumVal: sumVal, avgVal: avgVal, stdDev: stdDevVal };
            }
        };

        // === drawNineNetCanvas function ===
        /**
         * Draws the 9-net visualization of the sequence on a canvas.
         * @param {HTMLCanvasElement} canvas - The canvas element to draw on.
         * @param {Array<number>} sequence - The sequence of numbers to visualize.
         * @param {number} xVal - The X parameter used in the Collatz rule for color determination.
         * @param {string} divColor - Color for divisible numbers.
         * @param {string} mulColor - Color for multiply/add numbers.
         */
        function drawNineNetCanvas(canvas, sequence, xVal, divColor, mulColor) {
            const ctx = canvas.getContext("2d");
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Use the global constants for drawing logic
            const faceSize = FACE_SIZE;
            const padding = PADDING;
            const stepSize = STEP_SIZE;

            // Define the layout of the 9-net (a 3x3 grid of 3x3 faces)
            const layout = [
                { r: 0, c: 1 }, // Top
                { r: 1, c: 0 }, // Left
                { r: 1, c: 1 }, // Center-Left (main sequence starts here)
                { r: 1, c: 2 }, // Center
                { r: 1, c: 3 }, // Center-Right
                { r: 2, c: 1 }  // Bottom
            ];

            let sequenceIndex = 0; // Tracks the current position in the Collatz sequence

            // Iterate through each 'face' in the predefined layout
            for (const pos of layout) {
                // Iterate through the 3x3 grid of small squares within each face
                for (let i = 0; i < stepSize; i++) { // Row within the face
                    for (let j = 0; j < stepSize; j++) { // Column within the face
                        // Calculate the x and y coordinates for the current small square
                        const x = padding + (pos.c * stepSize + j) * faceSize;
                        const y = padding + (pos.r * stepSize + i) * faceSize;

                        let color = "#444"; // Default color for squares not representing a sequence number
                        let label = ""; // Optional label for the number

                        // Check if there's a corresponding number in the sequence
                        if (sequenceIndex < sequence.length) {
                            const val = sequence[sequenceIndex];
                            // Determine color based on the Collatz rule (divisible by X or not)
                            if (val % Math.abs(xVal) === 0) {
                                color = divColor; // Green if divisible
                            } else {
                                color = mulColor; // Orange if not divisible
                            }
                            label = val.toString(); // Set label to the number itself

                            // Ellipsis Logic for very large numbers
                            const maxChars = 5;
                            if (label.length > maxChars) {
                                const start = label.substring(0, Math.ceil((maxChars - 3) / 2));
                                const end = label.substring(label.length - Math.floor((maxChars - 3) / 2));
                                label = start + "..." + end;
                            }
                        }

                        // Draw the square
                        ctx.fillStyle = color;
                        ctx.fillRect(x, y, faceSize - 2, faceSize - 2); // -2 for spacing between squares

                        // Draw the number label if available
                        if (label) {
                            ctx.fillStyle = "#FFF"; // White text
                            // Dynamic font sizing
                            let currentFontSize = 10;
                            if (label.length > 7) {
                                currentFontSize = 6;
                            } else if (label.length > 5) {
                                currentFontSize = 8;
                            }
                            ctx.font = `${currentFontSize}px Arial`;
                            ctx.textAlign = "center";
                            ctx.textBaseline = "middle";
                            ctx.fillText(label, x + faceSize / 2 - 1, y + faceSize / 2 - 1); // Center text
                        }

                        sequenceIndex++; // Move to the next number in the sequence
                    }
                }
            }
        }

        // Function to parse URL parameters
        function getUrlParams() {
            const params = {};
            window.location.search.substring(1).split('&').forEach(param => {
                const parts = param.split('=');
                if (parts.length === 2) {
                    params[parts[0]] = decodeURIComponent(parts[1]);
                }
            });
            return params;
        }

        // Global variables for colors (can be overridden by URL params)
        let divColor = "#34d399"; // Default Green
        let mulColor = "#fb923c"; // Default Orange

        // Slideshow Animation Logic
        let slideshowInterval;
        let isSlideshowPlaying = false;
        let currentAnimationValue;
        let allBoxUniverses = []; // Stores all generated universes for bulk display/slideshow
        let filteredBoxUniverses = []; // Currently displayed universes (if filtering was applied)
        const MAX_ITERATIONS = 1000; // Max iterations for sequence calculation

        // Get elements for controls
        const animationAxisSelect = document.getElementById('animationAxis');
        const animationSpeedSlider = document.getElementById('animationSpeed');
        const speedValueSpan = document.getElementById('speedValue');
        const toggleSlideshowButton = document.getElementById('toggleSlideshow');
        const nMinInput = document.getElementById('nMin');
        const nMaxInput = document.getElementById('nMax');
        const xMinInput = document.getElementById('xMin');
        const xMaxInput = document.getElementById('xMax');
        const yMinInput = document.getElementById('yMin');
        const yMaxInput = document.getElementById('yMax');
        const zMinInput = document.getElementById('zMin');
        const zMaxInput = document.getElementById('zMax');
        const applyFiltersButton = document.getElementById('applyFilters');
        const gridContainer = document.getElementById('gridContainer');
        const nineNetCanvas = document.getElementById('nineNetCanvas'); // Main display canvas
        const paramDisplay = document.getElementById('paramDisplay'); // Main display text
        const sequenceInfo = document.getElementById('sequenceInfo'); // Main display text
        const sequenceNumbersDiv = document.getElementById('sequenceNumbers'); // Main display sequence numbers
        const sequenceRangeInfo = document.getElementById('sequenceRangeInfo'); // New element for main slicer display
        const sequenceSumInfo = document.getElementById('sequenceSumInfo'); // New element for main slicer display
        const sequenceAvgInfo = document.getElementById('sequenceAvgInfo'); // New element for main slicer display
        const sequenceStdDevInfo = document.getElementById('sequenceStdDevInfo'); // New element for main slicer display
        // There is no mainCanvasContainer in slicer.html itself, it's just the main canvas element.
        // const mainCanvasContainer = document.getElementById('mainCanvasContainer'); 

        // Gold star elements for slicer
        const nStarSlicer = document.getElementById('n-star'); 
        const xStarSlicer = document.getElementById('x-star');
        const yStarSlicer = document.getElementById('y-star');
        const zStarSlicer = document.getElementById('z-star');


        // Update speed value display
        animationSpeedSlider.addEventListener('input', () => {
            if (speedValueSpan) speedValueSpan.textContent = animationSpeedSlider.value;
        });

        // Function to toggle slideshow playback
        toggleSlideshowButton.addEventListener('click', () => {
            if (isSlideshowPlaying) {
                clearInterval(slideshowInterval);
                if (toggleSlideshowButton) toggleSlideshowButton.textContent = 'Play Slideshow';
                isSlideshowPlaying = false;
            } else {
                // Before starting, make sure we have universes to cycle through
                if (filteredBoxUniverses.length === 0) {
                    applyAndDrawFilters(); // Generate if not already present
                    if (filteredBoxUniverses.length === 0) {
                        // Still no universes, show an error or message
                        console.warn("No universes to play slideshow with. Adjust filter ranges.");
                        return;
                    }
                }

                if (toggleSlideshowButton) toggleSlideshowButton.textContent = 'Stop Slideshow';
                isSlideshowPlaying = true;
                
                const axis = animationAxisSelect.value;
                // Initialize currentAnimationValue to the min of the selected axis
                if (axis === 'N') {
                    currentAnimationValue = parseInt(nMinInput.value);
                } else if (axis === 'X') {
                    currentAnimationValue = parseInt(xMinInput.value);
                } else if (axis === 'Y') {
                    currentAnimationValue = parseInt(yMinInput.value);
                } else if (axis === 'Z') {
                    currentAnimationValue = parseInt(zMinInput.value);
                } else {
                    currentAnimationValue = 0; // Fallback
                }

                animationStep(); // Call the animation step immediately to draw the first frame
                slideshowInterval = setInterval(animationStep, parseInt(animationSpeedSlider.value));
            }
        });

        // Function to perform one step of the animation
        function animationStep() {
            const axis = animationAxisSelect.value;
            let minVal, maxVal, inputElement;

            if (axis === 'N') {
                minVal = parseInt(nMinInput.value);
                maxVal = parseInt(nMaxInput.value);
                inputElement = nMinInput;
            } else if (axis === 'X') {
                minVal = parseInt(xMinInput.value);
                maxVal = parseInt(xMaxInput.value);
                inputElement = xMinInput;
            } else if (axis === 'Y') {
                minVal = parseInt(yMinInput.value);
                maxVal = parseInt(yMaxInput.value);
                inputElement = yMinInput;
            } else if (axis === 'Z') {
                minVal = parseInt(zMinInput.value);
                maxVal = parseInt(zMaxInput.value);
                inputElement = zMinInput;
            }

            currentAnimationValue++;

            if (inputElement && currentAnimationValue > maxVal) { // Check inputElement for null
                currentAnimationValue = minVal;
            }

            if (inputElement) inputElement.value = currentAnimationValue; // Check inputElement for null
            applyAndDrawFilters(); // Re-apply filters and redraw the canvas with the new parameter
            updateGoldStarVisibilitySlicer(); // Update stars after input changes via animation
        }

        // Function to generate a set of Box Universes based on specified ranges
        function generateBoxUniverses(nMin, nMax, xMin, xMax, yMin, yMax, zMin, zMax) {
            const tempUniverses = [];
            const maxUniversesToGenerate = 100; // Limit to prevent performance issues
            let generatedCount = 0;

            for (let n = nMin; n <= nMax && generatedCount < maxUniversesToGenerate; n++) {
                for (let x = xMin; x <= xMax && generatedCount < maxUniversesToGenerate; x++) {
                    if (x === 0) continue; 
                    for (let y = yMin; y <= yMax && generatedCount < maxUniversesToGenerate; y++) {
                        for (let z = zMin; z <= zMax && generatedCount < maxUniversesToGenerate; z++) {
                            const result = generalizedCollatz(n, x, y, z, MAX_ITERATIONS);
                            if (result.type !== "error") {
                                tempUniverses.push({
                                    N: n, X: x, Y: y, Z: z,
                                    sequence: result.sequence,
                                    steps: result.steps,
                                    type: result.type,
                                    minVal: result.minVal, // min value in sequence
                                    maxVal: result.maxVal,  // max value in sequence
                                    sumVal: result.sumVal,   // sum of sequence values
                                    avgVal: result.avgVal,    // average of sequence values
                                    stdDev: result.stdDev     // standard deviation of sequence values
                                });
                                generatedCount++;
                            }
                        }
                    }
                }
            }
            return tempUniverses;
        }

        // Function to get current filter values from inputs (COMPLETED)
        function getFilterValues() {
            return {
                nMin: parseInt(nMinInput.value) || 1,
                nMax: parseInt(nMaxInput.value) || 50, // Default if empty
                xMin: parseInt(xMinInput.value) || 1,
                xMax: parseInt(xMaxInput.value) || 5,
                yMin: parseInt(yMinInput.value) || 1,
                yMax: parseInt(yMaxInput.value) || 5,
                zMin: parseInt(zMinInput.value) || 1,
                zMax: parseInt(zMaxInput.value) || 5
            };
        }

        // Function to display a specific universe in the main view
        function displayMainUniverse(universe) {
            if (!paramDisplay || !sequenceInfo || !sequenceNumbersDiv || !sequenceRangeInfo || !sequenceSumInfo || !sequenceAvgInfo || !sequenceStdDevInfo || !nineNetCanvas) {
                console.error("Missing one or more main display elements.");
                return;
            }

            paramDisplay.textContent = `N=${universe.N}, X=${universe.X}, Y=${universe.Y}, Z=${universe.Z}`;
            let typeText = universe.type.replace(/_/g, ' ');
            if (universe.type === "cycle") {
                typeText += ` (Cycle: ${universe.cycle.join(' → ')})`;
            } else if (universe.type === "reached_max_iterations" || universe.type === "exceeded_max_safe_integer") {
                typeText += ` (Final: ${universe.finalNum})`;
            }
            sequenceInfo.textContent = `Steps: ${universe.steps} | Type: ${typeText}`;
            sequenceNumbersDiv.textContent = universe.sequence.join(' → ');

            // Display statistics
            sequenceRangeInfo.textContent = `Range: [${universe.minVal.toLocaleString()}, ${universe.maxVal.toLocaleString()}]`;
            sequenceSumInfo.textContent = `Sum: ${universe.sumVal === "Too Large" ? 'Too Large' : universe.sumVal.toLocaleString()}`;
            sequenceAvgInfo.textContent = `Avg: ${typeof universe.avgVal === 'number' && Number.isFinite(universe.avgVal) ? universe.avgVal.toLocaleString(undefined, { maximumFractionDigits: 2 }) : 'N/A'}`;
            sequenceStdDevInfo.textContent = `StdDev: ${typeof universe.stdDev === 'number' && Number.isFinite(universe.stdDev) ? universe.stdDev.toLocaleString(undefined, { maximumFractionDigits: 2 }) : universe.stdDev}`;


            drawNineNetCanvas(nineNetCanvas, universe.sequence, universe.X, divColor, mulColor);
        }

        // Function to apply filters and draw the grid of universes (COMPLETED)
        function applyAndDrawFilters() {
            const filters = getFilterValues();
            filteredBoxUniverses = generateBoxUniverses(
                filters.nMin, filters.nMax,
                filters.xMin, filters.xMax,
                filters.yMin, filters.yMax,
                filters.zMin, filters.zMax
            );

            if (!gridContainer) {
                console.error("Grid container not found. Cannot apply filters.");
                return;
            }
            gridContainer.innerHTML = ''; // Clear existing grid items

            if (filteredBoxUniverses.length === 0) {
                gridContainer.innerHTML = '<p class="text-gray-400 text-center col-span-full">No universes found for the given ranges. Try adjusting the filters.</p>';
                // Clear main display if no universes are found for filtered view
                if (paramDisplay) paramDisplay.textContent = 'No specific sequence loaded. Use controls below.';
                if (sequenceInfo) sequenceInfo.textContent = '';
                if (sequenceNumbersDiv) sequenceNumbersDiv.textContent = '';
                if (nineNetCanvas) nineNetCanvas.getContext('2d').clearRect(0, 0, nineNetCanvas.width, nineNetCanvas.height);
                if (sequenceRangeInfo) sequenceRangeInfo.textContent = '';
                if (sequenceSumInfo) sequenceSumInfo.textContent = '';
                if (sequenceAvgInfo) sequenceAvgInfo.textContent = '';
                if (sequenceStdDevInfo) sequenceStdDevInfo.textContent = '';
                
                // There is no mainCanvasContainer in slicer.html. The main canvas itself can be shown/hidden.
                if (nineNetCanvas) nineNetCanvas.style.display = 'none'; 
                return;
            }

            // Display the first universe in the main canvas if it's the initial load or filters changed
            // Only update the main display if it's not currently showing a URL-loaded sequence,
            // or if the currently displayed URL sequence is outside the new filter range.
            const urlParams = new URLSearchParams(window.location.search); // Use URLSearchParams
            const urlN = parseInt(urlParams.get('n'));
            const urlX = parseInt(urlParams.get('x'));
            const urlY = parseInt(urlParams.get('y'));
            const urlZ = parseInt(urlParams.get('z'));

            const isUrlLoaded = !isNaN(urlN) && !isNaN(urlX) && !isNaN(urlY) && !isNaN(urlZ);
            let updateMainDisplay = true;

            if (isUrlLoaded) {
                // Check if the URL-loaded sequence is still within the new filter range
                const currentMainUniverse = { N: urlN, X: urlX, Y: urlY, Z: urlZ };
                const isStillInFilter = filteredBoxUniverses.some(u => 
                    u.N === currentMainUniverse.N && 
                    u.X === currentMainUniverse.X && 
                    u.Y === currentMainUniverse.Y && 
                    u.Z === currentMainUniverse.Z
                );
                if (isStillInFilter) {
                    updateMainDisplay = false; // Don't change the main display if URL-loaded is still valid
                }
            }
            
            if (updateMainDisplay && filteredBoxUniverses.length > 0) {
                displayMainUniverse(filteredBoxUniverses[0]);
            }


            filteredBoxUniverses.forEach(universe => {
                const gridItem = document.createElement('div');
                gridItem.className = 'grid-item';

                const canvasElement = document.createElement('canvas');
                // Set canvas internal resolution to match drawing constants
                canvasElement.width = NINE_NET_DRAW_WIDTH;
                canvasElement.height = NINE_NET_DRAW_HEIGHT;
                // CSS max-width and height:auto handle display sizing
                canvasElement.className = 'grid-item-canvas'; // Class for consistent styling

                drawNineNetCanvas(canvasElement, universe.sequence, universe.X, divColor, mulColor);

                const infoDiv = document.createElement('div');
                infoDiv.className = 'info';
                infoDiv.innerHTML = `N=${universe.N}, X=${universe.X}, Y=${universe.Y}, Z=${universe.Z}<br>`;
                let typeText = universe.type.replace(/_/g, ' ');
                if (universe.type === "cycle") {
                    typeText += ` (Cycle)`;
                } else if (universe.type === "reached_max_iterations" || universe.type === "exceeded_max_safe_integer") {
                    typeText += ` (Final: ${universe.finalNum !== undefined ? universe.finalNum.toLocaleString() : 'N/A'})`;
                }
                infoDiv.innerHTML += `Steps: ${universe.steps} | Type: ${typeText}`;
                infoDiv.innerHTML += `<br>Range: [${universe.minVal.toLocaleString()}, ${universe.maxVal.toLocaleString()}]`;
                infoDiv.innerHTML += `<br>Sum: ${universe.sumVal === "Too Large" ? 'Too Large' : universe.sumVal.toLocaleString()}`;
                infoDiv.innerHTML += `<br>Avg: ${typeof universe.avgVal === 'number' && Number.isFinite(universe.avgVal) ? universe.avgVal.toLocaleString(undefined, { maximumFractionDigits: 2 }) : 'N/A'}`;
                infoDiv.innerHTML += `<br>StdDev: ${typeof universe.stdDev === 'number' && Number.isFinite(universe.stdDev) ? universe.stdDev.toLocaleString(undefined, { maximumFractionDigits: 2 }) : universe.stdDev}`;


                const viewButton = document.createElement('button');
                viewButton.textContent = 'View in Main';
                viewButton.addEventListener('click', () => {
                    displayMainUniverse(universe);
                });

                gridItem.appendChild(canvasElement);
                gridItem.appendChild(infoDiv);
                gridItem.appendChild(viewButton);
                gridContainer.appendChild(gridItem);
            });

            updateGoldStarVisibilitySlicer(); // Update stars after filters are applied
        }

        // Function to update the gold star visibility in Slicer
        function updateGoldStarVisibilitySlicer() {
            // Ensure inputs exist before trying to read their values
            const xVal = xMinInput ? parseInt(xMinInput.value) : NaN; 
            const yVal = yMinInput ? parseInt(yMinInput.value) : NaN;
            const zVal = zMinInput ? parseInt(zMinInput.value) : NaN;

            const isStandardCollatz = (xVal === 2 && yVal === 3 && zVal === 1);

            // Hide/show stars based on the min values matching standard Collatz
            if (xStarSlicer) xStarSlicer.style.display = (xVal === 2) ? 'inline-block' : 'none';
            if (yStarSlicer) yStarSlicer.style.display = (yVal === 3) ? 'inline-block' : 'none';
            if (zStarSlicer) zStarSlicer.style.display = (zVal === 1) ? 'inline-block' : 'none';

            // N-star is always hidden as N doesn't define the rule
            if (nStarSlicer) nStarSlicer.style.display = 'none';
        }


        // Event listener for apply filters button
        if (applyFiltersButton) applyFiltersButton.addEventListener('click', applyAndDrawFilters);

        // Add event listeners to input fields to update gold star visibility
        // These will update the stars as the user types/changes values
        if (nMinInput) nMinInput.addEventListener('input', updateGoldStarVisibilitySlicer);
        if (xMinInput) xMinInput.addEventListener('input', updateGoldStarVisibilitySlicer);
        if (yMinInput) yMinInput.addEventListener('input', updateGoldStarVisibilitySlicer);
        if (zMinInput) zMinInput.addEventListener('input', updateGoldStarVisibilitySlicer);


        // Initial setup on page load
        window.addEventListener('DOMContentLoaded', () => {
            const params = getUrlParams();
            const n = parseInt(params.n);
            const x = parseInt(params.x);
            const y = parseInt(params.y);
            const z = parseInt(params.z);

            // Update color boxes based on initial values (defaults or URL)
            const divColorBox = document.getElementById('divColorBox');
            const mulColorBox = document.getElementById('mulColorBox');
            if (divColorBox) divColorBox.style.backgroundColor = divColor;
            if (mulColorBox) mulColorBox.style.backgroundColor = mulColor;

            // If URL parameters are present, display that single universe in the main canvas
            if (!isNaN(n) && !isNaN(x) && !isNaN(y) && !isNaN(z)) {
                // Set current animation values to URL values if they were provided
                if (nMinInput) nMinInput.value = n;
                if (nMaxInput) nMaxInput.value = n; // Set max to N to ensure it stays in range
                if (xMinInput) xMinInput.value = x;
                if (xMaxInput) xMaxInput.value = x;
                if (yMinInput) yMinInput.value = y;
                if (yMaxInput) yMaxInput.value = y;
                if (zMinInput) zMinInput.value = z;
                if (zMaxInput) zMaxInput.value = z;
                
                const result = generalizedCollatz(n, x, y, z, MAX_ITERATIONS);
                if (result.type !== "error") {
                    displayMainUniverse({ N: n, X: x, Y: y, Z: z, ...result });
                } else {
                    // Handle error for URL-loaded sequence
                    if (paramDisplay) paramDisplay.textContent = `Error for N=${n}, X=${x}, Y=${y}, Z=${z}`;
                    if (sequenceInfo) sequenceInfo.textContent = result.message;
                    if (sequenceNumbersDiv) sequenceNumbersDiv.textContent = '';
                    if (nineNetCanvas) nineNetCanvas.getContext('2d').clearRect(0, 0, nineNetCanvas.width, nineNetCanvas.height);
                    if (sequenceRangeInfo) sequenceRangeInfo.textContent = '';
                    if (sequenceSumInfo) sequenceSumInfo.textContent = '';
                    if (sequenceAvgInfo) sequenceAvgInfo.textContent = '';
                    if (sequenceStdDevInfo) sequenceStdDevInfo.textContent = '';
                }
                if (nineNetCanvas) nineNetCanvas.style.display = 'block'; // Ensure main canvas is visible
            } else {
                // If no parameters, perform initial draw with default values for the main canvas
                // Use a default universe to display initially if no URL params
                const defaultN = nMinInput ? parseInt(nMinInput.value) : 1; // Default fallback
                const defaultX = xMinInput ? parseInt(xMinInput.value) : 2;
                const defaultY = yMinInput ? parseInt(yMinInput.value) : 3;
                const defaultZ = zMinInput ? parseInt(zMinInput.value) : 1;

                const defaultResult = generalizedCollatz(defaultN, defaultX, defaultY, defaultZ, MAX_ITERATIONS);
                if (defaultResult.type !== "error") {
                    displayMainUniverse({ N: defaultN, X: defaultX, Y: defaultY, Z: defaultZ, ...defaultResult });
                } else {
                     // Handle error for default initial sequence
                    if (paramDisplay) paramDisplay.textContent = `Error with default sequence N=${defaultN}, X=${defaultX}, Y=${defaultY}, Z=${defaultZ}`;
                    if (sequenceInfo) sequenceInfo.textContent = defaultResult.message;
                    if (sequenceNumbersDiv) sequenceNumbersDiv.textContent = '';
                    if (nineNetCanvas) nineNetCanvas.getContext('2d').clearRect(0, 0, nineNetCanvas.width, nineNetCanvas.height);
                    if (sequenceRangeInfo) sequenceRangeInfo.textContent = '';
                    if (sequenceSumInfo) sequenceSumInfo.textContent = '';
                    if (sequenceAvgInfo) sequenceAvgInfo.textContent = '';
                    if (sequenceStdDevInfo) sequenceStdDevInfo.textContent = '';
                }
            }

            // Initial draw of bulk universes (always happens regardless of URL params)
            applyAndDrawFilters(); // This will populate the grid with default ranges if no specific sequence was loaded

            // Adjust canvas size if needed for responsiveness (for the single canvas at the top)
            function resizeMainCanvas() {
                if (!nineNetCanvas || !paramDisplay) { // Crucial checks for elements
                    return; 
                }
                const containerWidth = nineNetCanvas.parentElement ? nineNetCanvas.parentElement.clientWidth : NINE_NET_DRAW_WIDTH;
                const desiredDisplayWidth = Math.min(containerWidth * 0.9, NINE_NET_DRAW_WIDTH);
                nineNetCanvas.style.width = `${desiredDisplayWidth}px`;
                nineNetCanvas.style.height = 'auto'; // Important for aspect ratio

                // Redraw if there's currently a sequence displayed (e.g., from URL or initial default)
                // This prevents redrawing an empty canvas if an error occurred or no params were given
                const currentNtext = paramDisplay.textContent.split(',')[0];
                const currentNMatch = currentNtext ? currentNtext.match(/N=(\d+)/) : null;
                const currentN = currentNMatch ? parseInt(currentNMatch[1]) : NaN;

                const currentXtext = paramDisplay.textContent.split(',')[1];
                const currentXMatch = currentXtext ? currentXtext.match(/X=(\d+)/) : null;
                const currentX = currentXMatch ? parseInt(currentXMatch[1]) : NaN;
                
                const currentYtext = paramDisplay.textContent.split(',')[2];
                const currentYMatch = currentYtext ? currentYtext.match(/Y=(\d+)/) : null;
                const currentY = currentYMatch ? parseInt(currentYMatch[1]) : NaN;

                const currentZtext = paramDisplay.textContent.split(',')[3];
                const currentZMatch = currentZtext ? currentZtext.match(/Z=(\d+)/) : null;
                const currentZ = currentZMatch ? parseInt(currentZMatch[1]) : NaN;

                if (!isNaN(currentN) && !isNaN(currentX) && !isNaN(currentY) && !isNaN(currentZ) && nineNetCanvas.style.display !== 'none') {
                    const result = generalizedCollatz(currentN, currentX, currentY, currentZ, MAX_ITERATIONS);
                    if (result.type !== "error") {
                        drawNineNetCanvas(nineNetCanvas, result.sequence, currentX, divColor, mulColor);
                    }
                }
            }
            window.addEventListener('resize', resizeMainCanvas);
            resizeMainCanvas(); // Initial resize
            updateGoldStarVisibilitySlicer(); // Initial call to set gold star visibility on page load
        });
    </script>
</body>
</html>
