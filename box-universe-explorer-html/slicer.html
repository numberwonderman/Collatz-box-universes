<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2D Pseudo-3D Slicer</title>

    <!--
    LONG-TERM MISSION STATEMENT FOR THE BOX UNIVERSE EXPLORER PROJECT:

    This project aims to explore and visualize generalized Collatz sequences
    from novel perspectives, moving beyond traditional numerical analysis.
    The goal is not necessarily to prove the Collatz conjecture directly,
    but to build intuitive tools and models (like 9-nets and 2D/3D slicers)
    that reveal hidden patterns, behaviors, and relationships within the
    parameter space (N, X, Y, Z) that defines these universes.

    Ultimately, this work seeks to provide a unique "visual intuition"
    that can inspire new hypotheses, facilitate deeper understanding,
    and potentially lay groundwork for future mathematical insights,
    even if it takes months or years to fully realize.
    -->

    <style>
        body {
            display: flex;
            flex-direction: column; /* Allow content to stack vertically */
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            background-color: #282c34; /* Dark background */
            color: #ffffff; /* White text */
            font-family: Arial, sans-serif;
            padding: 20px; /* Add some padding around the content */
            box-sizing: border-box; /* Include padding in element's total width and height */
        }
        canvas {
            border: 2px solid #61dafb; /* Light blue border */
            background-color: #1c1f26; /* Slightly lighter dark for canvas background */
            max-width: 100%; /* Ensure canvas is responsive */
            height: auto; /* Maintain aspect ratio */
            display: block; /* Remove extra space below canvas */
            margin-top: 20px; /* Space between title and canvas */
        }
        h1 {
            text-align: center;
            margin-bottom: 10px;
        }
        p.mission-statement {
            max-width: 800px;
            text-align: center;
            font-size: 0.9em;
            color: #b0b0b0;
            margin-top: 20px;
            line-height: 1.5;
        }
        .controls {
            display: flex;
            gap: 20px;
            margin-top: 20px;
            flex-wrap: wrap; /* Allow controls to wrap on smaller screens */
            justify-content: center;
            align-items: center;
            padding: 10px;
            background-color: #3a3f47; /* Slightly lighter background for controls */
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }
        .color-control {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .color-control label {
            font-size: 0.9em;
        }
        input[type="color"] {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            width: 40px;
            height: 25px;
            background-color: transparent;
            border: none;
            cursor: pointer;
            padding: 0;
            border-radius: 5px;
        }
        input[type="color"]::-webkit-color-swatch-wrapper {
            padding: 0;
        }
        input[type="color"]::-webkit-color-swatch {
            border: 1px solid #555;
            border-radius: 4px;
        }
        input[type="color"]::-moz-color-swatch {
            border: 1px solid #555;
            border-radius: 4px;
        }
        .range-controls {
            display: flex;
            gap: 20px;
            margin-top: 20px;
            flex-wrap: wrap;
            justify-content: center;
            align-items: center;
            padding: 10px;
            background-color: #3a3f47; /* Consistent background with .controls */
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }
        .param-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
        }
        .param-group label {
            font-size: 0.9em;
            color: #b0b0b0;
        }
        .range-controls input[type="number"] {
            width: 60px;
            padding: 5px;
            border: 1px solid #555;
            background-color: #4a4f57; /* Consistent input background */
            color: #eee;
            border-radius: 4px;
            text-align: center;
        }
        button {
            background-color: #61dafb;
            color: #1c1f26;
            border: none;
            padding: 10px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: background-color 0.3s ease;
        }
        button:hover {
            background-color: #21a1f1;
        }
    </style>
</head>
<body>
    <h1>2D Pseudo-3D Slicer</h1>
    <p class="mission-statement">
        Part of the Box Universe Explorer project, this tool aims to visualize
        complex data by representing it as 3D geometric shapes and allowing
        interactive 2D cross-section slicing. The goal is to build visual intuition
        and explore patterns within multi-dimensional data.
    </p>

    <div class="controls">
        <div class="color-control">
            <label for="divisibleColor">Divisible Color:</label>
            <input type="color" id="divisibleColor" value="#34d399">
        </div>
        <div class="color-control">
            <label for="multiplyColor">Multiply/Add Color:</label>
            <input type="color" id="multiplyColor" value="#fb923c">
        </div>
    </div>
    <div class="range-controls">
        <div class="param-group">
            <label>N (Start Number):</label>
            <input type="number" id="nMin" value="1" min="1">
            <input type="number" id="nMax" value="50" min="1">
        </div>
        <div class="param-group">
            <label>X (Divisor):</label>
            <input type="number" id="xMin" value="2" min="1">
            <input type="number" id="xMax" value="5" min="1">
        </div>
        <div class="param-group">
            <label>Y (Multiplier):</label>
            <input type="number" id="yMin" value="3" min="1">
            <input type="number" id="yMax" value="5" min="1">
        </div>
        <div class="param-group">
            <label>Z (Adder):</label>
            <input type="number" id="zMin" value="1" min="1">
            <input type="number" id="zMax" value="5" min="1">
        </div>
        <button id="applyFilters">Apply Filters</button>
    </div>
    <canvas id="slicerCanvas" width="750" height="1200"></canvas>

    <script>
        const canvas = document.getElementById('slicerCanvas');
        const ctx = canvas.getContext('2d');

        // Get color input elements
        const divisibleColorInput = document.getElementById('divisibleColor');
        const multiplyColorInput = document.getElementById('multiplyColor');

        // Get range input elements
        const nMinInput = document.getElementById('nMin');
        const nMaxInput = document.getElementById('nMax');
        const xMinInput = document.getElementById('xMin');
        const xMaxInput = document.getElementById('xMax');
        const yMinInput = document.getElementById('yMin');
        const yMaxInput = document.getElementById('yMax'); // Corrected: was document='yMax'
        const zMinInput = document.getElementById('zMin');
        const zMaxInput = document.getElementById('zMax');
        const applyFiltersButton = document.getElementById('applyFilters');

        // --- GLOBAL CONSTANTS FOR 9-NET DIMENSIONS ---
        const faceSize = 30; // Size of each small square face
        const padding = 10; // Padding around the entire 9-net

        // --- RE-USING THE SEQUENCE FUNCTION ---
        const sequence = (num, x, y, z, maxiterations) => {
            if (x === 0) {
                return { sequence: [], type: "error", message: "X cannot be zero for the division rule." };
            }
            const output = [];
            output.push(num);
            let iterations = 0;
            const visitedNumbersMap = new Map();
            visitedNumbersMap.set(num, 0);

            while (num !== 1 && iterations < maxiterations) {
                if (Math.abs(num) > Number.MAX_SAFE_INTEGER) {
                    return { sequence: output, type: "exceeded_max_safe_integer", steps: iterations, finalNum: num };
                }

                let next_num;
                if (num % Math.abs(x) === 0) {
                    next_num = num / x;
                } else {
                    next_num = (Math.abs(y) || 3) * num + (z || 1);
                }

                if (visitedNumbersMap.has(next_num)) {
                    const cycleStartIndex = visitedNumbersMap.get(next_num);
                    const cycle = output.slice(cycleStartIndex);
                    return { sequence: output, type: "cycle", steps: iterations + 1, cycle: cycle };
                }
                visitedNumbersMap.set(next_num, output.length);

                num = next_num;
                output.push(num);
                iterations++;
            }

            if (num === 1) {
                return { sequence: output, type: "converges_to_1", steps: iterations };
            } else {
                return { sequence: output, type: "reached_max_iterations", steps: iterations, finalNum: num };
            }
        };

        // --- RE-USING THE DRAW 9-NET FUNCTION ---
        let divColor = divisibleColorInput.value;
        let mulColor = multiplyColorInput.value;

        function drawNineNetCanvas(canvasElement, sequence, xVal, offsetX = 0, offsetY = 0) {
            const ctx = canvasElement.getContext("2d");

            const stepSize = 3;
            const currentDivColor = divColor;
            const currentMulColor = mulColor;

            const layout = [
                { r: 0, c: 1 }, // Top
                { r: 1, c: 0 }, // Left
                { r: 1, c: 1 }, // Center-Left (main sequence starts here)
                { r: 1, c: 2 }, // Center
                { r: 1, c: 3 }, // Center-Right
                { r: 2, c: 1 }  // Bottom
            ];

            let sequenceIndex = 0;

            for (const pos of layout) {
                for (let i = 0; i < stepSize; i++) {
                    for (let j = 0; j < stepSize; j++) {
                        const x = offsetX + padding + (pos.c * stepSize + j) * faceSize;
                        const y = offsetY + padding + (pos.r * stepSize + i) * faceSize;

                        let color = "#444";
                        let label = "";

                        if (sequenceIndex < sequence.length) {
                            const val = sequence[sequenceIndex];
                            label = val.toString();

                            // Ellipsis Logic for very large numbers
                            const maxChars = 5;
                            if (label.length > maxChars) {
                                const start = label.substring(0, Math.ceil((maxChars - 3) / 2));
                                const end = label.substring(label.length - Math.floor((maxChars - 3) / 2));
                                label = start + "..." + end;
                            }

                            if (val % Math.abs(xVal) === 0) {
                                color = currentDivColor;
                            } else {
                                color = currentMulColor;
                            }
                        }

                        ctx.fillStyle = color;
                        ctx.fillRect(x, y, faceSize - 2, faceSize - 2);

                        if (label) {
                            ctx.fillStyle = "#FFF";
                            // Dynamic font sizing
                            let currentFontSize = 10;
                            if (label.length > 7) {
                                currentFontSize = 6;
                            } else if (label.length > 5) {
                                currentFontSize = 8;
                            }
                            ctx.font = `${currentFontSize}px Arial`;

                            ctx.textAlign = "center";
                            ctx.textBaseline = "middle";
                            ctx.fillText(label, x + faceSize / 2 - 1, y + faceSize / 2 - 1);
                        }
                        sequenceIndex++;
                    }
                }
            }
        }

        // --- DATA GENERATION ---
        const MAX_ITERATIONS = 1000;
        let allBoxUniverses = []; // This will store all generated universes
        let filteredBoxUniverses = []; // This will hold the currently displayed (filtered) box universes

        // --- NEW: Function to generate a set of Box Universes based on specified ranges ---
        function generateBoxUniverses(nMin, nMax, xMin, xMax, yMin, yMax, zMin, zMax) {
            const tempUniverses = [];
            // Limit the total number of universes generated to prevent performance issues
            // Adjust this limit based on your browser's performance
            const maxUniversesToGenerate = 100;
            let generatedCount = 0;

            for (let n = nMin; n <= nMax && generatedCount < maxUniversesToGenerate; n++) {
                for (let x = xMin; x <= xMax && generatedCount < maxUniversesToGenerate; x++) {
                    // X cannot be 0 for division rule
                    if (x === 0) continue; // Skip x=0 as it causes an error
                    for (let y = yMin; y <= yMax && generatedCount < maxUniversesToGenerate; y++) {
                        for (let z = zMin; z <= zMax && generatedCount < maxUniversesToGenerate; z++) {
                            const result = sequence(n, x, y, z, MAX_ITERATIONS);
                            if (result.type !== "error") { // Only push valid sequences
                                tempUniverses.push({
                                    N: n,
                                    X: x,
                                    Y: y,
                                    Z: z,
                                    sequence: result.sequence,
                                    steps: result.steps,
                                    type: result.type
                                });
                                generatedCount++;
                            }
                        }
                    }
                }
            }
            return tempUniverses;
        }

        // --- Function to get current filter values from inputs ---
        function getFilterValues() {
            return {
                nMin: parseInt(nMinInput.value) || 1,
                nMax: parseInt(nMaxInput.value) || Infinity,
                xMin: parseInt(xMinInput.value) || 1,
                xMax: parseInt(xMaxInput.value) || Infinity,
                yMin: parseInt(yMinInput.value) || 1,
                yMax: parseInt(yMaxInput.value) || Infinity,
                zMin: parseInt(zMinInput.value) || 1,
                zMax: parseInt(zMaxInput.value) || Infinity
            };
        }

        // --- Function to get current filter values from inputs and apply them ---
        function applyAndDrawFilters() {
            const filters = getFilterValues();

            // First, generate all possible box universes within the specified ranges
            // This ensures we always have the full set to potentially filter from
            allBoxUniverses = generateBoxUniverses(
                filters.nMin, filters.nMax,
                filters.xMin, filters.xMax,
                filters.yMin, filters.yMax,
                filters.zMin, filters.zMax
            );

            // For now, the "filter" is simply the generation based on ranges.
            // In the future, you could add more complex filtering criteria here
            // (e.g., filter by sequence type, number of steps, etc.)
            filteredBoxUniverses = allBoxUniverses;

            drawAllBoxUniverses();
        }

        // --- DRAWING FUNCTION ---
        function drawAllBoxUniverses() {
            ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear the entire canvas

            const netWidth = (3 * faceSize) + (2 * padding);
            const netHeight = (3 * faceSize) + (2 * padding);
            const spacingX = 40; // Horizontal space between nets
            const spacingY = 100; // Vertical space between nets (more for text label)

            const paddingOverall = 20; // Padding for the overall grid on the canvas
            const netsPerRow = Math.max(1, Math.floor((canvas.width - paddingOverall * 2 + spacingX) / (netWidth + spacingX)));

            if (netsPerRow <= 0) {
                ctx.fillStyle = '#b0b0b0';
                ctx.font = '16px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText("Canvas too small to draw nets. Increase canvas width or reduce spacing.", canvas.width / 2, canvas.height / 2);
                return;
            }

            filteredBoxUniverses.forEach((bu, index) => {
                const col = index % netsPerRow;
                const row = Math.floor(index / netsPerRow);

                const currentXOffset = paddingOverall + col * (netWidth + spacingX);
                const currentYOffset = paddingOverall + row * (netHeight + spacingY);

                // Draw a background for each 9-net to make it distinct
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                const backgroundWidth = netWidth;
                const backgroundHeight = netHeight + (spacingY - padding); // net height + space for text

                ctx.fillRect(currentXOffset, currentYOffset, backgroundWidth, backgroundHeight);

                drawNineNetCanvas(canvas, bu.sequence, bu.X, currentXOffset, currentYOffset);

                // Add text label below each net
                ctx.fillStyle = '#ffffff';
                ctx.font = '12px Arial';
                ctx.textAlign = 'left';
                ctx.textBaseline = 'top';

                const labelYStart = currentYOffset + netHeight + 10;
                ctx.fillText(`N=${bu.N}, X=${bu.X}, Y=${bu.Y}, Z=${bu.Z}`, currentXOffset + 10, labelYStart);
                ctx.fillText(`Steps: ${bu.steps}, Type: ${bu.type.replace(/_/g, ' ')}`, currentXOffset + 10, labelYStart + 15);
            });

            if (filteredBoxUniverses.length === 0) {
                ctx.fillStyle = '#b0b0b0';
                ctx.font = '16px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText("No Box Universes found for the current filter.", canvas.width / 2, canvas.height / 2);
            }
        }

        // --- EVENT LISTENERS ---
        divisibleColorInput.addEventListener('input', (event) => {
            divColor = event.target.value;
            drawAllBoxUniverses();
        });

        multiplyColorInput.addEventListener('input', (event) => {
            mulColor = event.target.value;
            drawAllBoxUniverses();
        });

        applyFiltersButton.addEventListener('click', applyAndDrawFilters);

        // Initial call to generate and draw universes based on default filter values
        applyAndDrawFilters();
        console.log("Slicer canvas is ready with full filtering functionality!");

    </script>
</body>
</html>
