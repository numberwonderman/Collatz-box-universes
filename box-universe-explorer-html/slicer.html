<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2D Pseudo-3D Slicer</title>

    <!--
    LONG-TERM MISSION STATEMENT FOR THE BOX UNIVERSE EXPLORER PROJECT:

    This project aims to explore and visualize generalized Collatz sequences
    from novel perspectives, moving beyond traditional numerical analysis.
    The goal is not necessarily to prove the Collatz conjecture directly,
    but to build intuitive tools and models (like 9-nets and 2D/3D slicers)
    that reveal hidden patterns, behaviors, and relationships within the
    parameter space (N, X, Y, Z).

    Ultimately, this work seeks to provide a unique "visual intuition"
    that can inspire new hypotheses, facilitate deeper understanding,
    and potentially lay groundwork for future mathematical insights,
    even if it takes months or years to fully realize.
    -->

    <style>
        .range-controls {
            display: flex;
            gap: 20px;
            margin-top: 20px;
            flex-wrap: wrap;
            justify-content: center;
            align-items: center;
            padding: 10px;
            border: 1px solid #61dafb;
            border-radius: 8px;
        }
        .param-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
        }
        .param-group label {
            font-size: 0.9em;
            color: #b0b0b0;
        }
        .range-controls input[type="number"] {
            width: 60px;
            padding: 5px;
            border: 1px solid #555;
            background-color: #333;
            color: #eee;
            border-radius: 4px;
            text-align: center;
        }
        .range-controls button {
            padding: 8px 15px;
            background-color: #61dafb;
            color: #282c34;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: background-color 0.2s ease;
        }
        .range-controls button:hover {
            background-color: #4fa3d1;
        }
        body {
            display: flex;
            flex-direction: column; /* Allow content to stack vertically */
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            background-color: #282c34; /* Dark background */
            color: #ffffff; /* White text */
            font-family: Arial, sans-serif;
            padding: 20px; /* Add some padding around the content */
            box-sizing: border-box; /* Include padding in element's total width and height */
        }
        canvas {
            border: 2px solid #61dafb; /* Light blue border */
            background-color: #1c1f26; /* Slightly lighter dark for canvas background */
            max-width: 100%; /* Ensure canvas is responsive */
            height: auto; /* Maintain aspect ratio */
            display: block; /* Remove extra space below canvas */
            margin-top: 20px; /* Space between title and canvas */
        }
        h1 {
            text-align: center;
            margin-bottom: 10px;
        }
        p.mission-statement {
            max-width: 800px;
            text-align: center;
            font-size: 0.9em;
            color: #b0b0b0;
            margin-top: 20px;
            line-height: 1.5;
        }
        .controls {
            display: flex;
            gap: 20px;
            margin-top: 20px;
            flex-wrap: wrap; /* Allow controls to wrap on smaller screens */
            justify-content: center;
            align-items: center;
        }
        .color-control {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .color-control label {
            font-size: 0.9em;
        }
        input[type="color"] {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            width: 40px;
            height: 25px;
            background-color: transparent;
            border: none;
            cursor: pointer;
            padding: 0;
            border-radius: 5px; /* Rounded corners for color input */
        }
        input[type="color"]::-webkit-color-swatch-wrapper {
            padding: 0;
        }
        input[type="color"]::-webkit-color-swatch {
            border: 1px solid #555; /* Add a subtle border to the color swatch */
            border-radius: 4px; /* Slightly smaller rounded corners for the swatch itself */
        }
        input[type="color"]::-moz-color-swatch {
            border: 1px solid #555;
            border-radius: 4px;
        }
    </style>
</head>
<body>
    <h1>2D Pseudo-3D Slicer</h1>
    <p class="mission-statement">
        Part of the Box Universe Explorer project, this tool aims to visualize
        complex data by representing it as 3D geometric shapes and allowing
        interactive 2D cross-section slicing. The goal is to build visual intuition
        and explore patterns within multi-dimensional data.
    </p>

    <div class="controls">
        <div class="color-control">
            <label for="divisibleColor">Divisible Color:</label>
            <input type="color" id="divisibleColor" value="#34d399">
        </div>
        <div class="color-control">
            <label for="multiplyColor">Multiply/Add Color:</label>
            <input type="color" id="multiplyColor" value="#fb923c">
        </div>
    </div>
    <div class="range-controls">
        <div class="param-group">
            <label>N (Start Number):</label>
            <input type="number" id="nMin" value="1" min="1">
            <input type="number" id="nMax" value="50" min="1">
        </div>
        <div class="param-group">
            <label>X (Divisor):</label>
            <input type="number" id="xMin" value="2" min="1">
            <input type="number" id="xMax" value="5" min="1">
        </div>
        <div class="param-group">
            <label>Y (Multiplier):</label>
            <input type="number" id="yMin" value="3" min="1">
            <input type="number" id="yMax" value="5" min="1">
        </div>
        <div class="param-group">
            <label>Z (Adder):</label>
            <input type="number" id="zMin" value="1" min="1">
            <input type="number" id="zMax" value="5" min="1">
        </div>
        <button id="applyFilters">Apply Filters</button>
    </div>
    <canvas id="slicerCanvas" width="750" height="1200"></canvas>

    <script>
        const canvas = document.getElementById('slicerCanvas');
        const ctx = canvas.getContext('2d');

        // Get color input elements
        const divisibleColorInput = document.getElementById('divisibleColor');
        const multiplyColorInput = document.getElementById('multiplyColor');
        // --- Get references to the new range input elements and button ---
const nMinInput = document.getElementById('nMin');
const nMaxInput = document.getElementById('nMax');
const xMinInput = document.getElementById('xMin');
const xMaxInput = document.getElementById('xMax');
const yMinInput = document.getElementById('yMin');
const yMaxInput = document.getElementById('yMax');
const zMinInput = document.getElementById('zMin');
const zMaxInput = document.getElementById('zMax');
const applyFiltersButton = document.getElementById('applyFilters');

        // --- GLOBAL CONSTANTS FOR 9-NET DIMENSIONS ---
        // These are defined here so they are accessible to both drawing functions
        const faceSize = 30; // Size of each small square face
        const padding = 10; // Padding around the entire 9-net

        // --- RE-USING THE SEQUENCE FUNCTION FROM INDEX.HTML ---
        // We'll need the Collatz sequence logic to generate our sample "Box Universes".
        // This is the same function you have in index.html.
        const sequence = (num, x, y, z, maxiterations) => {
            if (x === 0) {
                return { sequence: [], type: "error", message: "X cannot be zero for the division rule." };
            }
            const output = [];
            output.push(num);
            let iterations = 0;
            const visitedNumbersMap = new Map();
            visitedNumbersMap.set(num, 0);

            while (num !== 1 && iterations < maxiterations) {
                if (Math.abs(num) > Number.MAX_SAFE_INTEGER) {
                    return { sequence: output, type: "exceeded_max_safe_integer", steps: iterations, finalNum: num };
                }

                let next_num;
                if (num % Math.abs(x) === 0) {
                    next_num = num / x;
                } else {
                    next_num = (Math.abs(y) || 3) * num + (z || 1);
                }

                if (visitedNumbersMap.has(next_num)) {
                    const cycleStartIndex = visitedNumbersMap.get(next_num);
                    const cycle = output.slice(cycleStartIndex);
                    return { sequence: output, type: "cycle", steps: iterations + 1, cycle: cycle };
                }
                visitedNumbersMap.set(next_num, output.length);

                num = next_num;
                output.push(num);
                iterations++;
            }

            if (num === 1) {
                return { sequence: output, type: "converges_to_1", steps: iterations };
            } else {
                return { sequence: output, type: "reached_max_iterations", steps: iterations, finalNum: num };
            }
        };

        // --- RE-USING THE DRAW 9-NET FUNCTION FROM INDEX.HTML ---
        // We'll need this to draw the individual "Box Universes" (9-nets) on the slicer canvas.
        // Default canvas colors - These initialize the colors when the page loads
        let divColor = divisibleColorInput.value;
        let mulColor = multiplyColorInput.value;

        function drawNineNetCanvas(canvasElement, sequence, xVal, offsetX = 0, offsetY = 0) {
            const ctx = canvasElement.getContext("2d");

            // faceSize and padding are now global constants
            const stepSize = 3; // Number of small squares per 'face' side (3x3 grid)

            // Use the current colors from the global variables
            const currentDivColor = divColor;
            const currentMulColor = mulColor;

            const layout = [
                { r: 0, c: 1 }, // Top
                { r: 1, c: 0 }, // Left
                { r: 1, c: 1 }, // Center-Left (main sequence starts here)
                { r: 1, c: 2 }, // Center
                { r: 1, c: 3 }, // Center-Right
                { r: 2, c: 1 }  // Bottom
            ];

            let sequenceIndex = 0;

            for (const pos of layout) {
                for (let i = 0; i < stepSize; i++) {
                    for (let j = 0; j < stepSize; j++) {
                        const x = offsetX + padding + (pos.c * stepSize + j) * faceSize;
                        const y = offsetY + padding + (pos.r * stepSize + i) * faceSize;

                        let color = "#444";
                        let label = "";

                        if (sequenceIndex < sequence.length) {
                            const val = sequence[sequenceIndex];
                            label = val.toString();

                            // Ellipsis Logic for very large numbers
                            const maxChars = 5; // Max characters before truncating with ellipsis
                            if (label.length > maxChars) {
                                const start = label.substring(0, Math.ceil((maxChars - 3) / 2));
                                const end = label.substring(label.length - Math.floor((maxChars - 3) / 2));
                                label = start + "..." + end;
                            }

                            if (val % Math.abs(xVal) === 0) {
                                color = currentDivColor; // Use current divisible color
                            } else {
                                color = currentMulColor; // Use current multiply/add color
                            }
                        }

                        ctx.fillStyle = color;
                        ctx.fillRect(x, y, faceSize - 2, faceSize - 2);

                        if (label) {
                            ctx.fillStyle = "#FFF";
                            // Dynamic font sizing (adjusted for smaller faceSize if needed)
                            let currentFontSize = 10; // Default starting font size
                            if (label.length > 7) { // If number is very very long
                                currentFontSize = 6;
                            } else if (label.length > 5) { // If number is very long
                                currentFontSize = 8;
                            }
                            ctx.font = `${currentFontSize}px Arial`;

                            ctx.textAlign = "center";
                            ctx.textBaseline = "middle";
                            ctx.fillText(label, x + faceSize / 2 - 1, y + faceSize / 2 - 1);
                        }
                        sequenceIndex++;
                    }
                }
            }
        }


        // --- DATA STRUCTURE FOR OUR "BOX UNIVERSES" ---
        const boxUniverses = [];
        const MAX_ITERATIONS = 1000; // Adjusted for performance with more nets
 // This will hold the currently displayed (filtered) box universes
 let filteredBoxUniverses = []; // <-- Place it here, once.
        const testCases = [
            { N: 10, X: 2, Y: 3, Z: 1 },
            { N: 27, X: 2, Y: 3, Z: 1 },
            { N: 100, X: 2, Y: 3, Z: 1 },
            { N: 7, X: 5, Y: 2, Z: 1 },
            { N: 13, X: 2, Y: 5, Z: 1 },
            { N: 5, X: 3, Y: 4, Z: 2 },
            { N: 10000000000000000, X: 2, Y: 3, Z: 1 }, // Very large N
            { N: 10000000000000000, X: 3, Y: 4, Z: 5 },
            { N: 12345, X: 4, Y: 3, Z: 2 },
            { N: 98765, X: 2, Y: 7, Z: 1 },
            { N: 50000, X: 5, Y: 3, Z: 1 },
            { N: 20000, X: 2, Y: 3, Z: 10 },
            { N: 30000, X: 2, Y: 3, Z: 1 }, // Another standard Collatz for comparison
            { N: 67, X: 2, Y: 3, Z: 1 }, // A number known to have a long sequence
            { N: 42, X: 2, Y: 3, Z: 1 },
            { N: 1, X: 2, Y: 3, Z: 1 } // Test for starting at 1
        ];

        testCases.forEach(test => {
            const result = sequence(test.N, test.X, test.Y, test.Z, MAX_ITERATIONS);
            if (result.type !== "error") {
                boxUniverses.push({
                    N: test.N,
                    X: test.X,
                    Y: test.Y,
                    Z: test.Z,
                    sequence: result.sequence,
                    steps: result.steps,
                    type: result.type
                });
            }
        });
// --- Function to get current filter values from inputs and apply them ---
function applyAndDrawFilters() {
        const filters = getFilterValues(); // Get the latest filter values from input fields

        // Filter the original `boxUniverses` data
        filteredBoxUniverses = boxUniverses.filter(bu => {
            // Apply N (Start Number) filter
            if (bu.N < filters.nMin || bu.N > filters.nMax) {
                return false;
            }
            // Apply X (Divisor) filter
            if (bu.X < filters.xMin || bu.X > filters.xMax) {
                return false;
            }
            // Apply Y (Multiplier) filter
            if (bu.Y < filters.yMin || bu.Y > filters.yMax) {
                return false;
            }
            // Apply Z (Adder) filter
            if (bu.Z < filters.zMin || bu.Z > filters.zMax) {
                return false;
            }
            return true; // If all filters pass, include this box universe in the filtered list
        });

        // Now, call the drawing function to update the canvas with the filtered list
        drawAllBoxUniverses();
    }
        // --- DRAWING FUNCTION ---
        // This function will draw all the currently selected box universes
        function drawAllBoxUniverses() {
            ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear the entire canvas

            // Use the global faceSize and padding
            const netWidth = 3 * faceSize + 2 * padding; 
            const netHeight = 3 * faceSize + 2 * padding; 
            const spacingX = 40; // Horizontal space between nets
            const spacingY = 100; // Vertical space between nets (more for text label)

            const paddingOverall = 20; // Padding for the overall grid on the canvas
            const netsPerRow = Math.floor((canvas.width - paddingOverall * 2 + spacingX) / (netWidth + spacingX));

            filteredBoxUniverses.forEach((bu, index) => {
                const col = index % netsPerRow;
                const row = Math.floor(index / netsPerRow);

                const currentXOffset = paddingOverall + col * (netWidth + spacingX);
                const currentYOffset = paddingOverall + row * (netHeight + spacingY);

                // Draw a background for each 9-net to make it distinct
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                // Adjusted background size to correctly contain the net and its label
                const backgroundWidth = netWidth; 
                const backgroundHeight = netHeight + (spacingY - padding); // net height + space for text

                ctx.fillRect(currentXOffset, currentYOffset, backgroundWidth, backgroundHeight);

                drawNineNetCanvas(canvas, bu.sequence, bu.X, currentXOffset, currentYOffset);

                // Add text label below each net
                ctx.fillStyle = '#ffffff';
                ctx.font = '12px Arial';
                ctx.textAlign = 'left';
                ctx.textBaseline = 'top';
                ctx.fillText(`N=${bu.N}, X=${bu.X}, Y=${bu.Y}, Z=${bu.Z}`, currentXOffset, currentYOffset + netHeight + 5); // +5 for small margin
            });
        }
// --- Function to get current filter values from inputs ---
function getFilterValues() {
    return {
        nMin: parseInt(nMinInput.value) || 1, // Default to 1 if empty or invalid
        nMax: parseInt(nMaxInput.value) || Infinity, // Default to Infinity
        xMin: parseInt(xMinInput.value) || 1,
        xMax: parseInt(xMaxInput.value) || Infinity,
        yMin: parseInt(yMinInput.value) || 1,
        yMax: parseInt(yMaxInput.value) || Infinity,
        zMin: parseInt(zMinInput.value) || 1,
        zMax: parseInt(zMaxInput.value) || Infinity
    };
}
        // --- EVENT LISTENERS FOR COLOR PICKERS ---
        divisibleColorInput.addEventListener('input', (event) => {
            divColor = event.target.value; // Update the global variable
            drawAllBoxUniverses(); // Redraw with new color
        });

        multiplyColorInput.addEventListener('input', (event) => {
            mulColor = event.target.value; // Update the global variable
            drawAllBoxUniverses(); // Redraw with new color
        });
       // --- Event listener for the Apply Filters button ---
       applyFiltersButton.addEventListener('click', () => {
            applyAndDrawFilters(); // Call our new function to filter and redraw
        });
        applyAndDrawFilters(); // <--- TO THIS LINE (This will initialize filtering and drawing)
        console.log("Slicer canvas is ready with color pickers!");

    </script>
</body>
</html>
