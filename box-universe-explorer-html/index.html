<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Box Universe Explorer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        /* Custom scrollbar for history div */
        .custom-scrollbar::-webkit-scrollbar {
            width: 8px;
        }
        .custom-scrollbar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
            border-radius: 10px;
        }
        .custom-scrollbar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 10px;
        }
        .custom-scrollbar::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 10px;
        }
        body {
            font-family: 'Inter', sans-serif;
            /* Using Tailwind classes for the gradient background as per your original code */
            background: linear-gradient(to bottom right, #1d4ed8, #6d28d9);
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 1rem;
            color: #f8fafc;
        } 
        /* Tailwind bg-white bg-opacity-10 style for the main container */
        .bg-white.bg-opacity-10 {
            background-color: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px); /* Tailwind's backdrop-blur-lg equivalent */
            border-radius: 16px; /* Tailwind's rounded-2xl equivalent */
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25); /* Tailwind's shadow-2xl equivalent */
            border: 1px solid rgba(59, 130, 246, 0.5); /* Tailwind's border border-blue-700 equivalent */
        }
        /* Mission statement specific styling */
        p.project-mission {
            max-width: 700px; /* Constrain width for readability */
            text-align: center;
            font-size: 0.9em;
            color: #c0c0c0; /* Lighter color for secondary text */
            margin-top: -15px; /* Adjust spacing with elements above */
            margin-bottom: 25px; /* Space before next section */
            line-height: 1.5;
        }
        @media print {
            /* Hide UI elements not needed on a printout */
            button,
            input,
            label,
            #errorMessage {
                display: none;
            }

            /* Hide the 9-net canvases in history for print, but keep the main one if desired */
            #runsHistory canvas {
                display: none;
            }

            /* Force backgrounds and colors to be print-friendly (white background, dark text) */
            body {
                background: white !important;
                color: black !important;
                margin: 0; /* Remove default body margins for print */
            }

            /* Adjust main content container for print */
            .bg-white.bg-opacity-10 {
                background-color: white !important; /* Force white background */
                box-shadow: none !important;        /* Remove shadows */
                border: none !important;            /* Remove borders */
                backdrop-filter: none !important;   /* Disable blur */
                padding: 1rem !important;           /* Adjust padding for print */
            }

            /* Ensure history container and its content are visible and expand */
            #historyContainer {
                display: block !important;
                background-color: transparent !important; /* Remove background for print */
                border: none !important;
                box-shadow: none !important;
            }

            #runsHistory {
                max-height: none !important;        /* Allow content to expand fully */
                overflow-y: visible !important;     /* Prevent scrollbars */
            }

            /* Adjust individual history item backgrounds and text for print */
            .bg-blue-800.bg-opacity-40,
            .bg-blue-900.bg-opacity-60 {
                background-color: #f8f8f8 !important; /* Light gray background for items */
                border: 1px solid #ddd !important;
                color: #333 !important;             /* Dark text for readability */
            }

            /* Ensure all text is dark and readable on paper */
            .text-blue-200,
            .text-blue-300,
            .text-blue-100 {
                color: #333 !important;
            }
        } 
        /* Custom styling for the gold star/indicator */
        .gold-star {
            color: gold; /* Or use an emoji like '⭐' in the HTML directly */
            font-size: 1.25rem; /* text-xl */
            margin-left: 0.25rem; /* ml-1 */
            display: inline-block; /* To align with text */
        }
        /* Styling for disabled button */
        .disabled-btn {
            opacity: 0.6;
            cursor: not-allowed;
        }
    </style>
     <!--
    LONG-TERM MISSION STATEMENT FOR THE BOX UNIVERSE EXPLORER PROJECT:

    This project aims to explore and visualize generalized Collatz sequences
    from novel perspectives, moving beyond traditional numerical analysis.
    The goal is not necessarily to prove the Collatz conjecture directly,
    but to build intuitive tools and models (like 9-nets and 2D/3D slicers)
    that reveal hidden patterns, behaviors, and relationships within the
    parameter space (N, X, Y, Z).

    Ultimately, this work seeks to provide a unique "visual intuition"
    that can inspire new hypotheses, facilitate deeper understanding,
    and potentially lay groundwork for future mathematical insights,
    even if it takes months or years to fully realize.
    -->
</head>
<body class="min-h-screen bg-gradient-to-br from-blue-800 to-purple-900 flex items-center justify-center p-4">

    <div class="bg-white bg-opacity-10 backdrop-filter backdrop-blur-lg rounded-2xl shadow-2xl p-8 w-full max-w-4xl border border-blue-700">
        <h1 class="text-4xl font-extrabold text-center text-white mb-6 drop-shadow-lg">
            Box Universe Explorer
        </h1>

        <p class="project-mission">
            Explore and visualize generalized Collatz sequences to discover hidden
            patterns, foster intuition, and gain new perspectives on dynamical systems.
            A journey of visual discovery beyond traditional analysis.
        </p>

        <div class="mb-8 text-white text-lg leading-relaxed text-center">
            <p class="mb-3">
                Explore your generalized Collatz sequence where the rules are defined by X, Y, and Z coordinates.
            </p>
            <p class="font-semibold text-xl mb-4">
                Rule: If $n \pmod{X} = 0$, then $n \to n / X$. Otherwise, $n \to n \cdot Y + Z$.
            </p>
            <p class="text-sm text-blue-200">
                (Standard Collatz uses X=2, Y=3, Z=1)
            </p>
        </div>

        <h2 class="text-2xl font-semibold text-white mb-4">Single Sequence Calculation:</h2>
        <div class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-4 mb-6">
            <input type="number" id="startNumber" value="10" placeholder="Starting Number (n)"
                class="p-3 rounded-xl bg-blue-900 bg-opacity-50 text-white placeholder-blue-200 border border-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-400 transition duration-200" />
            <div class="flex items-center">
                <input type="number" id="xValue" value="2" placeholder="X (Divisor, non-zero)"
                    class="p-3 rounded-xl bg-blue-900 bg-opacity-50 text-white placeholder-blue-200 border border-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-400 transition duration-200" />
                <span id="x-star" class="gold-star">⭐</span>
            </div>
            <div class="flex items-center">
                <input type="number" id="yValue" value="3" placeholder="Y (Multiplier)"
                    class="p-3 rounded-xl bg-blue-900 bg-opacity-50 text-white placeholder-blue-200 border border-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-400 transition duration-200" />
                <span id="y-star" class="gold-star">⭐</span>
            </div>
            <div class="flex items-center">
                <input type="number" id="zValue" value="1" placeholder="Z (Additive Constant)"
                    class="p-3 rounded-xl bg-blue-900 bg-opacity-50 text-white placeholder-blue-200 border border-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-400 transition duration-200" />
                <span id="z-star" class="gold-star">⭐</span>
            </div>
        </div>

        <button id="calculateSingle"
            class="w-full px-6 py-3 bg-blue-600 hover:bg-blue-700 text-white font-bold rounded-xl shadow-lg transform transition duration-300 ease-in-out hover:scale-105 focus:outline-none focus:ring-2 focus:ring-blue-400 mb-4">
            Calculate Single Sequence
        </button>

        <!-- Container for the single 9-net canvas -->
        <div id="singleNineNetContainer" class="flex justify-center items-center mb-8">
            <!-- Canvas dimensions updated to correctly fit the 9-net drawing -->
            <canvas id="singleNineNetCanvas" width="380" height="290" class="rounded-md border border-blue-700"></canvas>
        </div>


        <h2 class="text-2xl font-semibold text-white mb-4">Bulk Box Universe Generation:</h2>
        <div class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4 mb-6">
            <input type="number" id="xStart" value="1" placeholder="X Start"
                class="p-3 rounded-xl bg-blue-900 bg-opacity-50 text-white placeholder-blue-200 border border-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-400 transition duration-200" />
            <input type="number" id="xEnd" value="3" placeholder="X End"
                class="p-3 rounded-xl bg-blue-900 bg-opacity-50 text-white placeholder-blue-200 border border-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-400 transition duration-200" />
            <input type="number" id="yStart" value="1" placeholder="Y Start"
                class="p-3 rounded-xl bg-blue-900 bg-opacity-50 text-white placeholder-blue-200 border border-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-400 transition duration-200" />
            <input type="number" id="yEnd" value="3" placeholder="Y End"
                class="p-3 rounded-xl bg-blue-900 bg-opacity-50 text-white placeholder-blue-200 border border-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-400 transition duration-200" />
            <input type="number" id="zStart" value="1" placeholder="Z Start"
                class="p-3 rounded-xl bg-blue-900 bg-opacity-50 text-white placeholder-blue-200 border border-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-400 transition duration-200" />
            <input type="number" id="zEnd" value="1" placeholder="Z End"
                class="p-3 rounded-xl bg-blue-900 bg-opacity-50 text-white placeholder-blue-200 border border-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-400 transition duration-200" />
        </div>

        <button id="generateBulk"
            class="w-full px-6 py-3 bg-purple-600 hover:bg-purple-700 text-white font-bold rounded-xl shadow-lg transform transition duration-300 ease-in-out hover:scale-105 focus:outline-none focus:ring-2 focus:ring-purple-400 mb-6">
            Generate Box Universe (Bulk)
        </button>
        
        <div class="flex flex-col sm:flex-row justify-center items-center gap-4 mb-6">
            <div class="flex items-center space-x-2 text-white">
                <label for="divColorPicker" class="font-semibold text-lg">Divisible Color:</label>
                <input type="color" id="divColorPicker" value="#34d399"
                                        class="w-10 h-10 rounded-md border-2 border-blue-700 cursor-pointer">
            </div>
            <div class="flex items-center space-x-2 text-white">
                <label for="mulColorPicker" class="font-semibold text-lg">Multiply/Add Color:</label>
                <input type="color" id="mulColorPicker" value="#fb923c"
                                        class="w-10 h-10 rounded-md border-2 border-blue-700 cursor-pointer">
            </div>
        </div>
        <p id="errorMessage" class="text-red-400 text-center mb-4 text-lg font-medium"></p>


    <div id="historyContainer" class="bg-blue-900 bg-opacity-50 rounded-xl p-6 shadow-inner border border-blue-700 hidden">
        <h2 class="text-2xl font-semibold text-white mb-4">Exploration History:</h2>
        <div id="runsHistory" class="max-h-96 overflow-y-auto custom-scrollbar pr-2">
        </div>
    </div>

    </div>

    <script>
        // Default canvas colors - These initialize the colors when the page loads
        window.divColor = "#34d399";
        window.mulColor = "#fb923c";

        // === Constants for 9-Net Dimensions ===
        // These are calculated based on the drawNineNetCanvas logic.
        // The 9-net layout is effectively 4 'face' columns wide and 3 'face' rows high.
        // Each face is 3x3 small squares.
        const FACE_SIZE = 30; // Size of each small square face
        const PADDING = 10; // Padding around the entire 9-net
        const STEP_SIZE = 3; // Number of small squares per 'face' side (3x3 grid)

        // Total internal drawing dimensions for a complete 9-net
        const NINE_NET_DRAW_WIDTH = (4 * STEP_SIZE * FACE_SIZE) + (2 * PADDING); // 4 faces horizontally * 3 squares/face * 30px/square + 2*10px padding
        const NINE_NET_DRAW_HEIGHT = (3 * STEP_SIZE * FACE_SIZE) + (2 * PADDING); // 3 faces vertically * 3 squares/face * 30px/square + 2*10px padding


        // === Generalized Collatz function ===
        // This function calculates the generalized Collatz sequence.
        // It includes error handling for X=0, cycle detection, and max iteration limit.
        // Now also calculates min, max, sum, and average values in the sequence.
        const sequence = (num, x, y, z, maxiterations) => {
            if (x === 0) {
                return { sequence: [], type: "error", message: "X cannot be zero for the division rule." };
            }
            const output = [];
            output.push(num);
            let iterations = 0;
            const visitedNumbersMap = new Map(); // Use a Map to store visited numbers AND their iteration index
            visitedNumbersMap.set(num, 0); // Store the starting number and its index (0)

            let minVal = num;
            let maxVal = num;
            let sumVal = num; // Initialize sum with the starting number

            while (num !== 1 && iterations < maxiterations) {
                // --- MAX NUMBER SAFETY BARRIER (from my fixes) ---
                // Check if the current number exceeds JavaScript's safe integer limit
                // Using Math.abs ensures it works for negative numbers if your rules allow them
                if (Math.abs(num) > Number.MAX_SAFE_INTEGER || !Number.isFinite(num)) { // Added !Number.isFinite(num)
                    const avgVal = sumVal / (iterations + 1);
                    // Standard Deviation calculation before returning
                    let stdDevVal = 0;
                    if (output.length > 1) {
                        const mean = avgVal;
                        // Corrected: use Math.pow(val - mean, 2) and sum of squared differences.
                        const sumOfSquaredDifferences = output.reduce((acc, val) => {
                            const diff = val - mean;
                            const squaredDiff = diff * diff;
                            // Check for overflow during squaring or sum of squared differences
                            if (!Number.isFinite(squaredDiff) || acc > Number.MAX_SAFE_INTEGER - squaredDiff) {
                                return Number.MAX_SAFE_INTEGER; // Indicate too large
                            }
                            return acc + squaredDiff;
                        }, 0);

                        if (sumOfSquaredDifferences === Number.MAX_SAFE_INTEGER) { // Check if sum itself was too large
                            stdDevVal = "Too Large";
                        } else {
                            const variance = sumOfSquaredDifferences / output.length;
                            const stdDev = Math.sqrt(variance);
                            if (!Number.isFinite(stdDev) || stdDev > Number.MAX_SAFE_INTEGER) {
                                stdDevVal = "Too Large";
                            } else {
                                stdDevVal = stdDev;
                            }
                        }
                    }
                    return { sequence: output, type: "exceeded_max_safe_integer", steps: iterations, finalNum: num, minVal: minVal, maxVal: maxVal, sumVal: sumVal, avgVal: avgVal, stdDev: stdDevVal };
                }

                let next_num;
                if (num % Math.abs(x) === 0) { // Using Math.abs(x) for the modulo check
                    next_num = num / x;
                } else {
                    next_num = (Math.abs(y) || 3) * num + (z || 1); // Using Math.abs(y)
                }

                // --- Additional robust check for next_num after calculation (from my fixes) ---
                if (!Number.isFinite(next_num) || Math.abs(next_num) > Number.MAX_SAFE_INTEGER) {
                    const avgVal = sumVal / (iterations + 1);
                     // Standard Deviation calculation before returning
                    let stdDevVal = 0;
                    if (output.length > 1) {
                        const mean = avgVal;
                        const sumOfSquaredDifferences = output.reduce((acc, val) => {
                            const diff = val - mean;
                            const squaredDiff = diff * diff;
                            if (!Number.isFinite(squaredDiff) || acc > Number.MAX_SAFE_INTEGER - squaredDiff) {
                                return Number.MAX_SAFE_INTEGER;
                            }
                            return acc + squaredDiff;
                        }, 0);

                        if (sumOfSquaredDifferences === Number.MAX_SAFE_INTEGER) {
                            stdDevVal = "Too Large";
                        } else {
                            const variance = sumOfSquaredDifferences / output.length;
                            const stdDev = Math.sqrt(variance);
                            if (!Number.isFinite(stdDev) || stdDev > Number.MAX_SAFE_INTEGER) {
                                stdDevVal = "Too Large";
                            } else {
                                stdDevVal = stdDev;
                            }
                        }
                    }
                    return { sequence: output, type: "exceeded_max_safe_integer", steps: iterations, finalNum: num, minVal: minVal, maxVal: maxVal, sumVal: sumVal, avgVal: avgVal, stdDev: stdDevVal };
                }


                // Update min/max values
                minVal = Math.min(minVal, next_num);
                maxVal = Math.max(maxVal, next_num);
                
                // Update sum, checking for potential overflow with very large numbers
                if (sumVal > Number.MAX_SAFE_INTEGER - Math.abs(next_num)) { // Check for potential overflow
                    sumVal = Number.MAX_SAFE_INTEGER; // Indicate it's too large for exact sum
                } else {
                    sumVal += next_num;
                }

                // --- ENHANCED CYCLE DETECTION ---
                if (visitedNumbersMap.has(next_num)) {
                    const avgVal = sumVal / (iterations + 1);
                    // Standard Deviation calculation for cycle
                    let stdDevVal = 0;
                    if (output.length > 1) {
                        const mean = avgVal;
                        const sumOfSquaredDifferences = output.reduce((acc, val) => {
                            const diff = val - mean;
                            const squaredDiff = diff * diff;
                            if (!Number.isFinite(squaredDiff) || acc > Number.MAX_SAFE_INTEGER - squaredDiff) {
                                return Number.MAX_SAFE_INTEGER;
                            }
                            return acc + squaredDiff;
                        }, 0);

                        if (sumOfSquaredDifferences === Number.MAX_SAFE_INTEGER) {
                            stdDevVal = "Too Large";
                        } else {
                            const variance = sumOfSquaredDifferences / output.length;
                            const stdDev = Math.sqrt(variance);
                            if (!Number.isFinite(stdDev) || stdDev > Number.MAX_SAFE_INTEGER) {
                                stdDevVal = "Too Large";
                            } else {
                                stdDevVal = stdDev;
                            }
                        }
                    }

                    const cycleStartIndex = visitedNumbersMap.get(next_num);
                    const cycle = output.slice(cycleStartIndex);
                    return { sequence: output, type: "cycle", steps: iterations + 1, cycle: cycle, minVal: minVal, maxVal: maxVal, sumVal: sumVal, avgVal: avgVal, stdDev: stdDevVal };
                }
                visitedNumbersMap.set(next_num, output.length); // Store the next number and its index in the output array

                num = next_num;
                output.push(num);
                iterations++;
            }

            // Calculate average and standard deviation at the end of the sequence
            const avgVal = sumVal / (iterations + 1); // +1 because output.length includes the starting number
            let stdDevVal = 0;
            if (output.length > 1) {
                const mean = avgVal;
                const sumOfSquaredDifferences = output.reduce((acc, val) => {
                    const diff = val - mean;
                    const squaredDiff = diff * diff;
                    if (!Number.isFinite(squaredDiff) || acc > Number.MAX_SAFE_INTEGER - squaredDiff) {
                        return Number.MAX_SAFE_INTEGER;
                    }
                    return acc + squaredDiff;
                }, 0);

                if (sumOfSquaredDifferences === Number.MAX_SAFE_INTEGER) {
                    stdDevVal = "Too Large";
                } else {
                    const variance = sumOfSquaredDifferences / output.length;
                    const stdDev = Math.sqrt(variance);
                    if (!Number.isFinite(stdDev) || stdDev > Number.MAX_SAFE_INTEGER) {
                        stdDevVal = "Too Large";
                    } else {
                        stdDevVal = stdDev;
                    }
                }
            }

            if (num === 1) {
                return { sequence: output, type: "converges_to_1", steps: iterations, minVal: minVal, maxVal: maxVal, sumVal: sumVal, avgVal: avgVal, stdDev: stdDevVal };
            } else {
                return { sequence: output, type: "reached_max_iterations", steps: iterations, finalNum: num, minVal: minVal, maxVal: maxVal, sumVal: sumVal, avgVal: avgVal, stdDev: stdDevVal };
            }
        };

        // === drawNineNetCanvas function ===
        /**
         * Draws the 9-net visualization of the sequence on a canvas.
         * @param {HTMLCanvasElement} canvas - The canvas element to draw on.
         * @param {Array<number>} sequence - The sequence of numbers to visualize.
         * @param {number} xVal - The X parameter used in the Collatz rule for color determination.
         * @param {string} divColor - Color for divisible numbers.
         * @param {string} mulColor - Color for multiply/add numbers.
         */
        function drawNineNetCanvas(canvas, sequence, xVal, divColor, mulColor) {
            const ctx = canvas.getContext("2d");
            // Clear the canvas before drawing
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Use the global constants for drawing logic
            const faceSize = FACE_SIZE;
            const padding = PADDING;
            const stepSize = STEP_SIZE;

            // Define the layout of the 9-net (a 3x3 grid of 3x3 faces)
            const layout = [
                { r: 0, c: 1 }, // Top
                { r: 1, c: 0 }, // Left
                { r: 1, c: 1 }, // Center-Left (main sequence starts here)
                { r: 1, c: 2 }, // Center
                { r: 1, c: 3 }, // Center-Right
                { r: 2, c: 1 }  // Bottom
            ];

            let sequenceIndex = 0; // Tracks the current position in the Collatz sequence

            // Iterate through each 'face' in the predefined layout
            for (const pos of layout) {
                // Iterate through the 3x3 grid of small squares within each face
                    for (let i = 0; i < stepSize; i++) { // Row within the face
                    for (let j = 0; j < stepSize; j++) { // Column within the face
                        // Calculate the x and y coordinates for the current small square
                        const x = padding + (pos.c * stepSize + j) * faceSize;
                        const y = padding + (pos.r * stepSize + i) * faceSize;

                        let color = "#444"; // Default color for squares not representing a sequence number
                        let label = ""; // Optional label for the number

                        // Check if there's a corresponding number in the sequence
                        if (sequenceIndex < sequence.length) {
                            const val = sequence[sequenceIndex];
                            // Determine color based on the Collatz rule (divisible by X or not)
                            if (val % Math.abs(xVal) === 0) {
                                color = divColor; // Green if divisible
                            } else {
                                color = mulColor; // Orange if not divisible
                            }
                            label = val.toString(); // Set label to the number itself

                            // Ellipsis Logic for very large numbers
                            const maxChars = 5;
                            if (label.length > maxChars) {
                                const start = label.substring(0, Math.ceil((maxChars - 3) / 2));
                                const end = label.substring(label.length - Math.floor((maxChars - 3) / 2));
                                label = start + "..." + end;
                            }
                        }

                        // Draw the square
                        ctx.fillStyle = color;
                        ctx.fillRect(x, y, faceSize - 2, faceSize - 2); // -2 for spacing between squares

                        // Draw the number label if available
                        if (label) {
                            ctx.fillStyle = "#FFF"; // White text
                            // Dynamic font sizing
                            let currentFontSize = 10;
                            if (label.length > 7) {
                                currentFontSize = 6;
                            } else if (label.length > 5) {
                                currentFontSize = 8;
                            }
                            ctx.font = `${currentFontSize}px Arial`;
                            ctx.textAlign = "center";
                            ctx.textBaseline = "middle";
                            ctx.fillText(label, x + faceSize / 2 - 1, y + faceSize / 2 - 1); // Center text
                        }

                        sequenceIndex++; // Move to the next number in the sequence
                    }
                }
            }
        }

        // Function to update the gold star visibility
        function updateGoldStarVisibility() {
            const xVal = parseInt(document.getElementById('xValue').value);
            const yVal = parseInt(document.getElementById('yValue').value);
            const zVal = parseInt(document.getElementById('zValue').value);

            const xStar = document.getElementById('x-star');
            const yStar = document.getElementById('y-star');
            const zStar = document.getElementById('z-star');

            if (xStar) xStar.style.display = (xVal === 2) ? 'inline-block' : 'none';
            if (yStar) yStar.style.display = (yVal === 3) ? 'inline-block' : 'none';
            if (zStar) zStar.style.display = (zVal === 1) ? 'inline-block' : 'none';
        }

        let calculatedRuns = []; // Global array to store runs

        /**
         * Helper function to validate a single number input.
         * @param {string} value - The input string value.
         * @param {string} name - The name of the input for error messages.
         * @param {boolean} allowZero - Whether zero is a valid input.
         * @returns {string|null} Error message if invalid, otherwise null.
         */
        const validateNumberInput = (value, name, allowZero = false) => {
            const num = parseInt(value, 10);
            if (isNaN(num) || (!allowZero && num === 0) || !Number.isInteger(num)) {
                return `${name} must be a valid integer${allowZero ? '' : ' (non-zero)'}.`;
            }
            return null; // No error
        };

        /**
         * Renders the calculated runs into the history display.
         */
        const renderHistory = () => {
            const runsHistoryDiv = document.getElementById('runsHistory');
            const historyContainer = document.getElementById('historyContainer');

            if (!runsHistoryDiv || !historyContainer) {
                console.error("History elements not found. Cannot render history.");
                return;
            }

            runsHistoryDiv.innerHTML = ''; // Clear previous history

            if (calculatedRuns.length === 0) {
                historyContainer.classList.add('hidden');
                return;
            } else {
                historyContainer.classList.remove('hidden');
            }

            // Iterate in reverse to show newest runs at the top
            for (let i = calculatedRuns.length - 1; i >= 0; i--) {
                const run = calculatedRuns[i];
                const runDiv = document.createElement('div');
                runDiv.className = 'bg-blue-800 bg-opacity-40 rounded-lg p-4 mb-4 border border-blue-600 last:mb-0';

                const title = document.createElement('h3');
                title.className = 'text-xl font-bold text-blue-200 mb-2';
                title.textContent = `N=${run.startNum}, X=${run.X}, Y=${run.Y}, Z=${run.Z}`;
                runDiv.appendChild(title);

                const stepsInfo = document.createElement('p');
                stepsInfo.className = 'text-blue-300 mb-2';
                let typeText = run.type.replace(/_/g, ' ');

                if (run.type === "reached_max_iterations") {
                    typeText += ` - Ended at ${run.finalNum}`;
                } else if (run.type === "exceeded_max_safe_integer") {
                    typeText += ` - Ended at ${run.finalNum}`; // No need to repeat "Exceeded safe integer limit" as it's in the type
                } else if (run.type === "cycle") {
                    typeText += ` - Cycle: ${run.cycle.join(' → ')}`;
                }
                stepsInfo.textContent = `Steps: ${run.steps} (Type: ${typeText})`;
                runDiv.appendChild(stepsInfo);

                // Add min/max info
                const rangeInfo = document.createElement('p');
                rangeInfo.className = 'text-blue-300 text-sm mb-2';
                rangeInfo.textContent = `Range: ${run.minVal.toLocaleString()} to ${run.maxVal.toLocaleString()}`;
                runDiv.appendChild(rangeInfo);

                // Add sum info
                const sumInfo = document.createElement('p');
                sumInfo.className = 'text-blue-300 text-sm mb-2';
                // Check if sumVal is a number and format it, otherwise display as is (e.g., "Too Large")
                sumInfo.textContent = `Sum: ${typeof run.sumVal === 'number' ? run.sumVal.toLocaleString() : run.sumVal}`;
                runDiv.appendChild(sumInfo);

                // Add average info
                const avgInfo = document.createElement('p');
                avgInfo.className = 'text-blue-300 text-sm mb-2';
                // Check if avgVal is a number and format it, otherwise display as is (e.g., "Too Large")
                avgInfo.textContent = `Average: ${typeof run.avgVal === 'number' ? run.avgVal.toLocaleString(undefined, { maximumFractionDigits: 2 }) : run.avgVal}`;
                runDiv.appendChild(avgInfo);

                // Add Standard Deviation info
                const stdDevInfo = document.createElement('p');
                stdDevInfo.className = 'text-blue-300 text-sm mb-2';
                // Check if stdDev is a number and format it, otherwise display as is (e.g., "Too Large")
                stdDevInfo.textContent = `Standard Deviation: ${typeof run.stdDev === 'number' ? run.stdDev.toLocaleString(undefined, { maximumFractionDigits: 2 }) : run.stdDev}`;
                runDiv.appendChild(stdDevInfo);


                const sequenceDiv = document.createElement('div');
                sequenceDiv.className = 'bg-blue-900 bg-opacity-60 rounded-md p-3 max-h-32 overflow-y-auto text-blue-100 text-sm break-words mb-4';
                sequenceDiv.textContent = Array.isArray(run.sequence) ? run.sequence.join(' → ') : 'Invalid sequence data';
                runDiv.appendChild(sequenceDiv);

                // Add "View in 3D" button for this run (DISABLED with tooltip)
                const viewIn3dBtn = document.createElement('button');
                viewIn3dBtn.textContent = 'View in 3D';
                viewIn3dBtn.className = 'mt-4 px-4 py-2 bg-purple-500 text-white font-bold rounded-md shadow-md transition duration-200 ease-in-out disabled-btn';
                viewIn3dBtn.setAttribute('disabled', 'true');
                viewIn3dBtn.setAttribute('title', '3D visualization temporarily unavailable due to local server compatibility. Please ensure Live Server is active.');
                runDiv.appendChild(viewIn3dBtn);

                // Add "View in 2D" button for this run
                const viewIn2dBtn = document.createElement('button');
                viewIn2dBtn.textContent = 'View in 2D';
                viewIn2dBtn.className = 'mt-4 ml-2 px-4 py-2 bg-blue-500 hover:bg-blue-600 text-white font-bold rounded-md shadow-md transition duration-200 ease-in-out transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-blue-400';
                viewIn2dBtn.setAttribute('title', 'Requires server to view (e.g., via Live Server)'); // Tooltip for 2D
                viewIn2dBtn.addEventListener('click', () => {
                    // Pass all relevant parameters to slicer.html
                    const url = `slicer.html?n=${run.startNum}&x=${run.X}&y=${run.Y}&z=${run.Z}&divColor=${encodeURIComponent(window.divColor)}&mulColor=${encodeURIComponent(window.mulColor)}`;
                    window.open(url, '_blank'); // Open slicer.html in a new browser tab
                });
                runDiv.appendChild(viewIn2dBtn);

                runsHistoryDiv.appendChild(runDiv);
            }
        };

        /**
         * Handles the calculation logic for a single sequence.
         */
        const calculateSingleButton = document.getElementById('calculateSingle');
        if (calculateSingleButton) {
            calculateSingleButton.addEventListener('click', () => {
                const startNumberInput = document.getElementById('startNumber');
                const xValueInput = document.getElementById('xValue');
                const yValueInput = document.getElementById('yValue');
                const zValueInput = document.getElementById('zValue');
                const errorMessage = document.getElementById('errorMessage');

                if (!startNumberInput || !xValueInput || !yValueInput || !zValueInput || !errorMessage) {
                    console.error("One or more single calculation input/output elements not found.");
                    return;
                }

                const num = parseInt(startNumberInput.value, 10);
                const X = parseInt(xValueInput.value, 10);
                const Y = parseInt(yValueInput.value, 10);
                const Z = parseInt(zValueInput.value, 10);

                // Validate inputs
                let err = validateNumberInput(startNumberInput.value, 'Starting Number', false);
                if (err) { errorMessage.textContent = err; return; }
                err = validateNumberInput(xValueInput.value, 'X (Divisor)', false);
                if (err) { errorMessage.textContent = err; return; }
                err = validateNumberInput(yValueInput.value, 'Y (Multiplier)', true);
                if (err) { errorMessage.textContent = err; return; }
                err = validateNumberInput(zValueInput.value, 'Z (Additive Constant)', true);
                if (err) { errorMessage.textContent = err; return; }

                errorMessage.textContent = ''; // Clear previous errors

                const maxStepsForCalculation = 10000; // Hardcoded max iterations
                const result = sequence(num, X, Y, Z, maxStepsForCalculation);

                if (result.type === "error") {
                    errorMessage.textContent = result.message;
                    // Clear the single 9-net canvas on error
                    const singleNineNetCanvas = document.getElementById('singleNineNetCanvas');
                    if (singleNineNetCanvas) {
                        const ctx = singleNineNetCanvas.getContext('2d');
                        ctx.clearRect(0, 0, singleNineNetCanvas.width, singleNineNetCanvas.height);
                    }
                    return;
                }

                const newRun = {
                    id: Date.now(),
                    startNum: num,
                    X: X,
                    Y: Y,
                    Z: Z,
                    sequence: result.sequence,
                    steps: result.steps,
                    type: result.type,
                    cycle: result.cycle, // Include cycle if present
                    finalNum: result.finalNum, // Include finalNum if present (for max iterations/safe integer)
                    minVal: result.minVal, // min value in sequence
                    maxVal: result.maxVal,  // max value in sequence
                    sumVal: result.sumVal,   // sum of sequence values
                    avgVal: result.avgVal,   // average of sequence values
                    stdDev: result.stdDev    // standard deviation of sequence values
                };

                // Draw the single 9-net immediately after calculation
                const singleNineNetCanvas = document.getElementById('singleNineNetCanvas');
                if (singleNineNetCanvas) {
                    drawNineNetCanvas(singleNineNetCanvas, newRun.sequence, newRun.X, window.divColor, window.mulColor);
                }

                calculatedRuns.push(newRun); // Add to the end, then renderHistory will reverse for display
                renderHistory();

                // Display specific messages for non-converging sequences
                if (newRun.type === "reached_max_iterations") {
                    errorMessage.textContent = `Sequence for N=${num}, X=${X}, Y=${Y}, Z=${Z} did not reach 1. It ended at ${newRun.finalNum} after ${newRun.steps} steps.`;
                } else if (newRun.type === "exceeded_max_safe_integer") {
                    errorMessage.textContent = `Sequence for N=${num}, X=${X}, Y=${Y}, Z=${Z} exceeded JavaScript's safe integer limit or became infinite. It ended at ${newRun.finalNum} after ${newRun.steps} steps.`;
                } else if (newRun.type === "cycle") {
                    errorMessage.textContent = `Sequence for N=${num}, X=${X}, Y=${Y}, Z=${Z} entered a cycle: ${newRun.cycle.join(' → ')}.`;
                }
            });
        }

        /**
         * Handles the bulk generation logic.
         */
        const generateBulkButton = document.getElementById('generateBulk');
        if (generateBulkButton) {
            generateBulkButton.addEventListener('click', () => {
                const startNumberInput = document.getElementById('startNumber');
                const xStartInput = document.getElementById('xStart');
                const xEndInput = document.getElementById('xEnd');
                const yStartInput = document.getElementById('yStart');
                const yEndInput = document.getElementById('yEnd');
                const zStartInput = document.getElementById('zStart');
                const zEndInput = document.getElementById('zEnd');
                const errorMessage = document.getElementById('errorMessage');

                if (!startNumberInput || !xStartInput || !xEndInput || !yStartInput || !yEndInput || !zStartInput || !zEndInput || !errorMessage) {
                    console.error("One or more bulk generation input/output elements not found.");
                    return;
                }

                const num = parseInt(startNumberInput.value, 10);
                let tempNewRuns = [];
                const maxStepsForCalculation = 10000; // Hardcoded max iterations

                // Validate starting number
                let err = validateNumberInput(startNumberInput.value, 'Starting Number', false);
                if (err) { errorMessage.textContent = err; return; }

                // Parse range inputs
                const parsedXStart = parseInt(xStartInput.value, 10);
                const parsedXEnd = parseInt(xEndInput.value, 10);
                const parsedYStart = parseInt(yStartInput.value, 10);
                const parsedYEnd = parseInt(yEndInput.value, 10);
                const parsedZStart = parseInt(zStartInput.value, 10);
                const parsedZEnd = parseInt(zEndInput.value, 10);

                // Validate ranges
                if (isNaN(parsedXStart) || isNaN(parsedXEnd) || parsedXStart > parsedXEnd || !Number.isInteger(parsedXStart) || !Number.isInteger(parsedXEnd)) {
                    errorMessage.textContent = 'X range must be valid integers (X Start <= X End).'; return;
                }
                if (isNaN(parsedYStart) || isNaN(parsedYEnd) || parsedYStart > parsedYEnd || !Number.isInteger(parsedYStart) || !Number.isInteger(parsedYEnd)) {
                    errorMessage.textContent = 'Y range must be valid integers (Y Start <= Y End).'; return;
                }
                if (isNaN(parsedZStart) || isNaN(parsedZEnd) || parsedZStart > parsedZEnd || !Number.isInteger(parsedZStart) || !Number.isInteger(parsedZEnd)) {
                    errorMessage.textContent = 'Z range must be valid integers (Z Start <= Z End).'; return;
                }

                errorMessage.textContent = ''; // Clear previous errors

                let idCounter = 0; // Used to ensure unique IDs for runs generated in quick succession

                for (let x = parsedXStart; x <= parsedXEnd; x++) {
                    if (x === 0) {
                    // Optionally provide a message that X=0 is skipped in bulk
                    console.warn("Skipping X=0 in bulk generation as it's an invalid divisor.");
                    continue;
                    }

                    for (let y = parsedYStart; y <= parsedYEnd; y++) {
                        for (let z = parsedZStart; z <= parsedZEnd; z++) {
                        const result = sequence(num, x, y, z, maxStepsForCalculation);

                        if (result.type !== "error") { // Only add valid results
                            tempNewRuns.push({
                            id: Date.now() + (idCounter++), // Unique ID
                            startNum: num,
                            X: x,
                            Y: y,
                            Z: z,
                            sequence: result.sequence,
                            steps: result.steps,
                            type: result.type,
                            cycle: result.cycle, // Include cycle if present
                            finalNum: result.finalNum, // Include finalNum if present
                            minVal: result.minVal, // min value in sequence
                            maxVal: result.maxVal,  // max value in sequence
                            sumVal: result.sumVal,   // sum of sequence values
                            avgVal: result.avgVal,    // average of sequence values
                            stdDev: result.stdDev     // standard deviation of sequence values
                            });
                        }
                        }
                    }
                }
                calculatedRuns.push(...tempNewRuns); // Add all new runs to the end
                renderHistory(); // Re-render the history

                if (tempNewRuns.length === 0) {
                    errorMessage.textContent = "No valid sequences generated for the given ranges. Check inputs.";
                } else {
                    errorMessage.textContent = ""; // Clear error if successful
                }
            });
        }

        // Event Listeners for color pickers to update global colors and re-render history
        const divColorPicker = document.getElementById('divColorPicker');
        if (divColorPicker) {
            divColorPicker.addEventListener('input', (e) => {
                window.divColor = e.target.value; // Get the new color from the picker
                // Re-draw the single 9-net if it's currently displayed
                const singleNineNetCanvas = document.getElementById('singleNineNetCanvas');
                const startNumberInput = document.getElementById('startNumber');
                const xValueInput = document.getElementById('xValue');
                const yValueInput = document.getElementById('yValue');
                const zValueInput = document.getElementById('zValue');

                if (singleNineNetCanvas && startNumberInput && xValueInput && yValueInput && zValueInput) {
                    const currentN = parseInt(startNumberInput.value);
                    const currentX = parseInt(xValueInput.value);
                    const currentY = parseInt(yValueInput.value);
                    const currentZ = parseInt(zValueInput.value);
                    const maxSteps = 10000;
                    const result = sequence(currentN, currentX, currentY, currentZ, maxSteps);
                    if (result.type !== "error") {
                        drawNineNetCanvas(singleNineNetCanvas, result.sequence, currentX, window.divColor, window.mulColor);
                    }
                }
                renderHistory(); // Re-render all the displayed nets in history (if any) with the new color
            });
        }

        const mulColorPicker = document.getElementById('mulColorPicker');
        if (mulColorPicker) {
            mulColorPicker.addEventListener('input', (e) => {
                window.mulColor = e.target.value; // Get the new color from the picker
                // Re-draw the single 9-net if it's currently displayed
                const singleNineNetCanvas = document.getElementById('singleNineNetCanvas');
                const startNumberInput = document.getElementById('startNumber');
                const xValueInput = document.getElementById('xValue');
                const yValueInput = document.getElementById('yValue');
                const zValueInput = document.getElementById('zValue');

                if (singleNineNetCanvas && startNumberInput && xValueInput && yValueInput && zValueInput) {
                    const currentN = parseInt(startNumberInput.value);
                    const currentX = parseInt(xValueInput.value);
                    const currentY = parseInt(yValueInput.value);
                    const currentZ = parseInt(zValueInput.value);
                    const maxSteps = 10000;
                    const result = sequence(currentN, currentX, currentY, currentZ, maxSteps);
                    if (result.type !== "error") {
                        drawNineNetCanvas(singleNineNetCanvas, result.sequence, currentX, window.divColor, window.mulColor);
                    }
                }
                renderHistory(); // Re-render all the displayed nets in history (if any) with the new color
            });
        }

        // Add event listeners to input fields to update gold star visibility
        const xValueInputForStar = document.getElementById('xValue');
        const yValueInputForStar = document.getElementById('yValue');
        const zValueInputForStar = document.getElementById('zValue');

        if (xValueInputForStar) xValueInputForStar.addEventListener('input', updateGoldStarVisibility);
        if (yValueInputForStar) yValueInputForStar.addEventListener('input', updateGoldStarVisibility);
        if (zValueInputForStar) zValueInputForStar.addEventListener('input', updateGoldStarVisibility);

        /**
         * Parses URL parameters.
         * @returns {Object} An object containing key-value pairs of URL parameters.
         */
        function getUrlParams() {
            const params = {};
            window.location.search.substring(1).split('&').forEach(param => {
                const parts = param.split('=');
                if (parts.length === 2) {
                    params[parts[0]] = decodeURIComponent(parts[1]);
                }
            });
            return params;
        }

        // Initial render (on page load)
        document.addEventListener('DOMContentLoaded', () => {
            const params = getUrlParams();
            const nParam = params.n;
            const xParam = params.x;
            const yParam = params.y;
            const zParam = params.z;

            // Get elements for initial setup
            const startNumberInput = document.getElementById('startNumber');
            const xValueInput = document.getElementById('xValue');
            const yValueInput = document.getElementById('yValue');
            const zValueInput = document.getElementById('zValue');
            const calculateSingleButton = document.getElementById('calculateSingle');
            const singleNineNetCanvas = document.getElementById('singleNineNetCanvas');

            // If parameters are present, pre-fill inputs and trigger calculation
            if (nParam && xParam && yParam && zParam && startNumberInput && xValueInput && yValueInput && zValueInput && calculateSingleButton) {
                startNumberInput.value = nParam;
                xValueInput.value = xParam;
                yValueInput.value = yParam;
                zValueInput.value = zParam;
                
                // Automatically trigger the single calculation
                calculateSingleButton.click();
            } else if (singleNineNetCanvas && startNumberInput && xValueInput && yValueInput && zValueInput) {
                // If no parameters, perform initial draw with default values
                const defaultN = parseInt(startNumberInput.value);
                const defaultX = parseInt(xValueInput.value);
                const defaultY = parseInt(yValueInput.value);
                const defaultZ = parseInt(zValueInput.value);
                const maxSteps = 10000;
                const defaultResult = sequence(defaultN, defaultX, defaultY, defaultZ, maxSteps);
                if (defaultResult.type !== "error") {
                    drawNineNetCanvas(singleNineNetCanvas, defaultResult.sequence, defaultX, window.divColor, window.mulColor);
                }
            }

            renderHistory(); // Ensure history container visibility is correctly set on load
            updateGoldStarVisibility(); // Initial call to set gold star visibility on page load
        });
    </script>
</body>
</html>
