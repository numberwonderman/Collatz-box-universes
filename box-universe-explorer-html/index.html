<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Box Universe Explorer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom scrollbar for history div */
        .custom-scrollbar::-webkit-scrollbar {
            width: 8px;
        }
        .custom-scrollbar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
            border-radius: 10px;
        }
        .custom-scrollbar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 10px;
        }
        .custom-scrollbar::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 255, 255, 0.3);
        }
      body {
        font-family: 'Inter', sans-serif;
    } 
     @media print {
        /* Hide UI elements not needed on a printout */
        button,
        input,
        label,
        #errorMessage {
            display: none;
        }

        /* Hide the 9-net canvases */
        canvas {
            display: none;
        }

        /* Force backgrounds and colors to be print-friendly (white background, dark text) */
        body {
            background: white !important;
            color: black !important;
            margin: 0; /* Remove default body margins for print */
        }

        /* Adjust main content container for print */
        .bg-white.bg-opacity-10 {
            background-color: white !important; /* Force white background */
            box-shadow: none !important;        /* Remove shadows */
            border: none !important;            /* Remove borders */
            backdrop-filter: none !important;   /* Disable blur */
            padding: 1rem !important;           /* Adjust padding for print */
        }

        /* Ensure history container and its content are visible and expand */
        #historyContainer {
            display: block !important;
            background-color: transparent !important; /* Remove background for print */
            border: none !important;
            box-shadow: none !important;
        }

        #runsHistory {
            max-height: none !important;        /* Allow content to expand fully */
            overflow-y: visible !important;     /* Prevent scrollbars */
        }

        /* Adjust individual history item backgrounds and text for print */
        .bg-blue-800.bg-opacity-40,
        .bg-blue-900.bg-opacity-60 {
            background-color: #f8f8f8 !important; /* Light gray background for items */
            border: 1px solid #ddd !important;
            color: #333 !important;             /* Dark text for readability */
        }

        /* Ensure all text is dark and readable on paper */
        .text-blue-200,
        .text-blue-300,
        .text-blue-100 {
            color: #333 !important;
        }
    } 
    </style>
</head>
<body class="min-h-screen bg-gradient-to-br from-blue-800 to-purple-900 flex items-center justify-center p-4">

    <div class="bg-white bg-opacity-10 backdrop-filter backdrop-blur-lg rounded-2xl shadow-2xl p-8 w-full max-w-4xl border border-blue-700">
        <h1 class="text-4xl font-extrabold text-center text-white mb-6 drop-shadow-lg">
            Box Universe Explorer
        </h1>

        <div class="mb-8 text-white text-lg leading-relaxed text-center">
            <p class="mb-3">
                Explore your generalized Collatz sequence where the rules are defined by X, Y, and Z coordinates.
            </p>
            <p class="font-semibold text-xl mb-4">
                Rule: If $n \pmod{X} = 0$, then $n \to n / X$. Otherwise, $n \to n \cdot Y + Z$.
            </p>
            <p class="text-sm text-blue-200">
                (Standard Collatz uses X=2, Y=3, Z=1)
            </p>
        </div>

        <h2 class="text-2xl font-semibold text-white mb-4">Single Sequence Calculation:</h2>
        <div class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-4 mb-6">
            <input type="number" id="startNumber" value="10" placeholder="Starting Number (n)"
                class="p-3 rounded-xl bg-blue-900 bg-opacity-50 text-white placeholder-blue-200 border border-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-400 transition duration-200" />
            <input type="number" id="xValue" value="2" placeholder="X (Divisor, non-zero)"
                class="p-3 rounded-xl bg-blue-900 bg-opacity-50 text-white placeholder-blue-200 border border-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-400 transition duration-200" />
            <input type="number" id="yValue" value="3" placeholder="Y (Multiplier)"
                class="p-3 rounded-xl bg-blue-900 bg-opacity-50 text-white placeholder-blue-200 border border-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-400 transition duration-200" />
            <input type="number" id="zValue" value="1" placeholder="Z (Additive Constant)"
                class="p-3 rounded-xl bg-blue-900 bg-opacity-50 text-white placeholder-blue-200 border border-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-400 transition duration-200" />
        </div>

        <button id="calculateSingle"
            class="w-full px-6 py-3 bg-blue-600 hover:bg-blue-700 text-white font-bold rounded-xl shadow-lg transform transition duration-300 ease-in-out hover:scale-105 focus:outline-none focus:ring-2 focus:ring-blue-400 mb-8">
            Calculate Single Sequence
        </button>

        <h2 class="text-2xl font-semibold text-white mb-4">Bulk Box Universe Generation:</h2>
        <div class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4 mb-6">
            <input type="number" id="xStart" value="1" placeholder="X Start"
                class="p-3 rounded-xl bg-blue-900 bg-opacity-50 text-white placeholder-blue-200 border border-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-400 transition duration-200" />
            <input type="number" id="xEnd" value="3" placeholder="X End"
                class="p-3 rounded-xl bg-blue-900 bg-opacity-50 text-white placeholder-blue-200 border border-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-400 transition duration-200" />
            <input type="number" id="yStart" value="1" placeholder="Y Start"
                class="p-3 rounded-xl bg-blue-900 bg-opacity-50 text-white placeholder-blue-200 border border-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-400 transition duration-200" />
            <input type="number" id="yEnd" value="3" placeholder="Y End"
                class="p-3 rounded-xl bg-blue-900 bg-opacity-50 text-white placeholder-blue-200 border border-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-400 transition duration-200" />
            <input type="number" id="zStart" value="1" placeholder="Z Start"
                class="p-3 rounded-xl bg-blue-900 bg-opacity-50 text-white placeholder-blue-200 border border-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-400 transition duration-200" />
            <input type="number" id="zEnd" value="1" placeholder="Z End"
                class="p-3 rounded-xl bg-blue-900 bg-opacity-50 text-white placeholder-blue-200 border border-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-400 transition duration-200" />
        </div>

        <button id="generateBulk"
            class="w-full px-6 py-3 bg-purple-600 hover:bg-purple-700 text-white font-bold rounded-xl shadow-lg transform transition duration-300 ease-in-out hover:scale-105 focus:outline-none focus:ring-2 focus:ring-purple-400 mb-6">
            Generate Box Universe (Bulk)
        </button>
        
    <div class="flex flex-col sm:flex-row justify-center items-center gap-4 mb-6">
        <div class="flex items-center space-x-2 text-white">
            <label for="divColorPicker" class="font-semibold text-lg">Divisible Color:</label>
            <input type="color" id="divColorPicker" value="#34d399"
                       class="w-10 h-10 rounded-md border-2 border-blue-700 cursor-pointer">
        </div>
        <div class="flex items-center space-x-2 text-white">
            <label for="mulColorPicker" class="font-semibold text-lg">Multiply/Add Color:</label>
            <input type="color" id="mulColorPicker" value="#fb923c"
                       class="w-10 h-10 rounded-md border-2 border-blue-700 cursor-pointer">
        </div>
    </div>
    <p id="errorMessage" class="text-red-400 text-center mb-4 text-lg font-medium"></p>


<div id="historyContainer" class="bg-blue-900 bg-opacity-50 rounded-xl p-6 shadow-inner border border-blue-700 hidden">
    <h2 class="text-2xl font-semibold text-white mb-4">Exploration History:</h2>
    <div id="runsHistory" class="max-h-96 overflow-y-auto custom-scrollbar pr-2">
    </div>
</div>

    </div>

    <script>
        // Default canvas colors - These initialize the colors when the page loads
        window.divColor = "#34d399";
        window.mulColor = "#fb923c";

        // === YOUR ORIGINAL SEQUENCE FUNCTION ===
        // This function calculates the generalized Collatz sequence.
        // It includes error handling for X=0, cycle detection, and max iteration limit.
        const sequence = (num, x, y, z, maxiterations) => {
            if (x === 0) {
                return { sequence: [], type: "error", message: "X cannot be zero for the division rule." };
            }
            const output = [];
            output.push(num);
            let iterations = 0;
            const visited = new Set(); // For cycle detection
            visited.add(num);

            while (num !== 1 && iterations < maxiterations) {
                let next_num;
                if (num % Math.abs(x) === 0) { // Using Math.abs(x) for the modulo check
                    next_num = num / x;
                } else {
                    next_num = (Math.abs(y) || 3) * num + (z || 1); // Using Math.abs(y)
                }

                // Cycle detection
                if (visited.has(next_num)) {
                    output.push(next_num); // Add the number that completes the cycle
                    return { sequence: output, type: "cycle", steps: iterations + 1 };
                }
                visited.add(next_num); // Add to visited set

                num = next_num;
                output.push(num);
                iterations++;
            }

            if (num === 1) {
                return { sequence: output, type: "converges_to_1", steps: iterations };
            } else {
                return { sequence: output, type: "reached_max_iterations", steps: iterations };
            }
        };

        /**
         * Draws the 9-net visualization of the sequence on a canvas.
         * @param {HTMLCanvasElement} canvas - The canvas element to draw on.
         * @param {Array<number>} sequence - The sequence of numbers to visualize.
         * @param {number} xVal - The X parameter used in the Collatz rule for color determination.
         */
        function drawNineNetCanvas(canvas, sequence, xVal) {
            const ctx = canvas.getContext("2d");
            // Clear the canvas before drawing
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            const faceSize = 30; // Size of each small square face
            const padding = 10; // Padding around the entire 9-net
            const stepSize = 3; // Number of small squares per 'face' side (3x3 grid)

            // Get the colors from the global window variables, with fallbacks
            const divColor = window.divColor || "#34d399"; // green for Divisible
            const mulColor = window.mulColor || "#fb923c"; // orange for Multiply/Add

            // Define the layout of the 9-net (a 3x3 grid of 3x3 faces)
            const layout = {
                // Each key represents a 'face' in the 9-net, with its row (r) and column (c) in the larger grid
                top: { r: 0, c: 1 },
                left: { r: 1, c: 0 },
                centerLeft: { r: 1, c: 1 },
                center: { r: 1, c: 2 },
                centerRight: { r: 1, c: 3 },
                bottom: { r: 2, c: 1 }
            };

            let sequenceIndex = 0; // Tracks the current position in the Collatz sequence

            // Iterate through each 'face' in the predefined layout
            for (const key in layout) {
                const pos = layout[key]; // Get the row and column of the current face

                // Iterate through the 3x3 grid of small squares within each face
                for (let i = 0; i < stepSize; i++) { // Row within the face
                    for (let j = 0; j < stepSize; j++) { // Column within the face
                        // Calculate the x and y coordinates for the current small square
                        const x = padding + (pos.c * stepSize + j) * faceSize;
                        const y = padding + (pos.r * stepSize + i) * faceSize;

                        let color = "#444"; // Default color for squares not representing a sequence number
                        let label = ""; // Optional label for the number

                        // Check if there's a corresponding number in the sequence
                        if (sequenceIndex < sequence.length) {
                            const val = sequence[sequenceIndex];
                            // Determine color based on the Collatz rule (divisible by X or not)
                            if (val % Math.abs(xVal) === 0) {
                                color = divColor; // Green if divisible
                            } else {
                                color = mulColor; // Orange if not divisible
                            }
                            label = val.toString(); // Set label to the number itself
                        }

                        // Draw the square
                        ctx.fillStyle = color;
                        ctx.fillRect(x, y, faceSize - 2, faceSize - 2); // -2 for spacing between squares

                        // Draw the number label if available
                        if (label) {
                            ctx.fillStyle = "#FFF"; // White text
                            ctx.font = "10px Arial"; // Smaller font for numbers
                            ctx.textAlign = "center";
                            ctx.textBaseline = "middle";
                            ctx.fillText(label, x + faceSize / 2 - 1, y + faceSize / 2 - 1); // Center text
                        }

                        sequenceIndex++; // Move to the next number in the sequence
                    }
                }
            }
        }

        let calculatedRuns = []; // Global array to store runs

        /**
         * Helper function to validate a single number input.
         * @param {string} value - The input string value.
         * @param {string} name - The name of the input for error messages.
         * @param {boolean} allowZero - Whether zero is a valid input.
         * @returns {string|null} Error message if invalid, otherwise null.
         */
        const validateNumberInput = (value, name, allowZero = false) => {
            const num = parseInt(value, 10);
            if (isNaN(num) || (!allowZero && num === 0) || !Number.isInteger(num)) {
                return `${name} must be a valid integer${allowZero ? '' : ' (non-zero)'}.`;
            }
            return null; // No error
        };

        /**
         * Renders the calculated runs into the history display.
         */
        const renderHistory = () => {
            const runsHistoryDiv = document.getElementById('runsHistory');
            runsHistoryDiv.innerHTML = ''; // Clear previous history
            const historyContainer = document.getElementById('historyContainer');

            if (calculatedRuns.length === 0) {
                historyContainer.classList.add('hidden');
                return;
            } else {
                historyContainer.classList.remove('hidden');
            }

            // Iterate in reverse to show newest runs at the top
            for (let i = calculatedRuns.length - 1; i >= 0; i--) {
                const run = calculatedRuns[i];
                const runDiv = document.createElement('div');
                runDiv.className = 'bg-blue-800 bg-opacity-40 rounded-lg p-4 mb-4 border border-blue-600 last:mb-0';

                const title = document.createElement('h3');
                title.className = 'text-xl font-bold text-blue-200 mb-2';
                title.textContent = `N=${run.startNum}, X=${run.X}, Y=${run.Y}, Z=${run.Z}`;
                runDiv.appendChild(title);

                const stepsInfo = document.createElement('p');
                stepsInfo.className = 'text-blue-300 mb-2';
                let typeText = run.type.replace(/_/g, ' ');
                if (run.type === "reached_max_iterations") {
                    typeText += ` - Ended at ${run.sequence[run.sequence.length - 1]}`;
                }
                stepsInfo.textContent = `Steps: ${run.steps} (Type: ${typeText})`;
                runDiv.appendChild(stepsInfo);

                const sequenceDiv = document.createElement('div');
                sequenceDiv.className = 'bg-blue-900 bg-opacity-60 rounded-md p-3 max-h-32 overflow-y-auto text-blue-100 text-sm break-words mb-4';
                sequenceDiv.textContent = Array.isArray(run.sequence) ? run.sequence.join(' → ') : 'Invalid sequence data';
                runDiv.appendChild(sequenceDiv);

                // Create and draw the canvas
                const canvas = document.createElement('canvas');
                canvas.width = 300; // Fixed width
                canvas.height = 300; // Fixed height
                canvas.className = 'rounded-md border border-blue-700 mt-2';
                runDiv.appendChild(canvas);
                drawNineNetCanvas(canvas, run.sequence, run.X);

                runsHistoryDiv.appendChild(runDiv);
            }
        };

        /**
         * Handles the calculation logic for a single sequence.
         */
        document.getElementById('calculateSingle').addEventListener('click', () => {
            const startNumberInput = document.getElementById('startNumber');
            const xValueInput = document.getElementById('xValue');
            const yValueInput = document.getElementById('yValue');
            const zValueInput = document.getElementById('zValue');
            const errorMessage = document.getElementById('errorMessage');

            const num = parseInt(startNumberInput.value, 10);
            const X = parseInt(xValueInput.value, 10);
            const Y = parseInt(yValueInput.value, 10);
            const Z = parseInt(zValueInput.value, 10);

            // Validate inputs
            let err = validateNumberInput(startNumberInput.value, 'Starting Number', false);
            if (err) { errorMessage.textContent = err; return; }
            err = validateNumberInput(xValueInput.value, 'X (Divisor)', false);
            if (err) { errorMessage.textContent = err; return; }
            err = validateNumberInput(yValueInput.value, 'Y (Multiplier)', true);
            if (err) { errorMessage.textContent = err; return; }
            err = validateNumberInput(zValueInput.value, 'Z (Additive Constant)', true);
            if (err) { errorMessage.textContent = err; return; }

            errorMessage.textContent = ''; // Clear previous errors

            const maxStepsForCalculation = 10000; // Hardcoded max iterations
            const result = sequence(num, X, Y, Z, maxStepsForCalculation);

            if (result.type === "error") {
                errorMessage.textContent = result.message;
                return;
            }

            const newRun = {
                id: Date.now(),
                startNum: num,
                X: X,
                Y: Y,
                Z: Z,
                sequence: result.sequence,
                steps: result.steps,
                type: result.type,
            };

            calculatedRuns.push(newRun); // Add to the end, then renderHistory will reverse for display
            renderHistory();

            // Display specific messages for non-converging sequences
            if (newRun.type === "reached_max_iterations") {
                errorMessage.textContent = `Sequence for N=${num}, X=${X}, Y=${Y}, Z=${Z} did not reach 1. It ended at ${newRun.sequence[newRun.sequence.length - 1]} after ${newRun.steps} steps.`;
            } else if (newRun.type === "cycle") {
                errorMessage.textContent = `Sequence for N=${num}, X=${X}, Y=${Y}, Z=${Z} entered a cycle.`;
            }
        });

        /**
         * Handles the bulk generation logic.
         */
        document.getElementById('generateBulk').addEventListener('click', () => {
            const startNumberInput = document.getElementById('startNumber');
            const xStartInput = document.getElementById('xStart');
            const xEndInput = document.getElementById('xEnd');
            const yStartInput = document.getElementById('yStart');
            const yEndInput = document.getElementById('yEnd');
            const zStartInput = document.getElementById('zStart');
            const zEndInput = document.getElementById('zEnd');
            const errorMessage = document.getElementById('errorMessage');

            const num = parseInt(startNumberInput.value, 10);
            let tempNewRuns = [];
            const maxStepsForCalculation = 10000; // Hardcoded max iterations

            // Validate starting number
            let err = validateNumberInput(startNumberInput.value, 'Starting Number', false);
            if (err) { errorMessage.textContent = err; return; }

            // Parse range inputs
            const parsedXStart = parseInt(xStartInput.value, 10);
            const parsedXEnd = parseInt(xEndInput.value, 10);
            const parsedYStart = parseInt(yStartInput.value, 10);
            const parsedYEnd = parseInt(yEndInput.value, 10);
            const parsedZStart = parseInt(zStartInput.value, 10);
            const parsedZEnd = parseInt(zEndInput.value, 10);

            // Validate ranges
            if (isNaN(parsedXStart) || isNaN(parsedXEnd) || parsedXStart > parsedXEnd || !Number.isInteger(parsedXStart) || !Number.isInteger(parsedXEnd)) {
              errorMessage.textContent = 'X range must be valid integers (X Start <= X End).'; return;
            }
            if (isNaN(parsedYStart) || isNaN(parsedYEnd) || parsedYStart > parsedYEnd || !Number.isInteger(parsedYStart) || !Number.isInteger(parsedYEnd)) {
              errorMessage.textContent = 'Y range must be valid integers (Y Start <= Y End).'; return;
            }
            if (isNaN(parsedZStart) || isNaN(parsedZEnd) || parsedZStart > parsedZEnd || !Number.isInteger(parsedZStart) || !Number.isInteger(parsedZEnd)) {
              errorMessage.textContent = 'Z range must be valid integers (Z Start <= Z End).'; return;
            }

            errorMessage.textContent = ''; // Clear previous errors

            let idCounter = 0; // Used to ensure unique IDs for runs generated in quick succession

            for (let x = parsedXStart; x <= parsedXEnd; x++) {
              if (x === 0) {
                // Optionally provide a message that X=0 is skipped in bulk
                console.warn("Skipping X=0 in bulk generation as it's an invalid divisor.");
                continue;
              }

              for (let y = parsedYStart; y <= parsedYEnd; y++) {
                for (let z = parsedZStart; z <= parsedZEnd; z++) {
                  const result = sequence(num, x, y, z, maxStepsForCalculation);

                  if (result.type !== "error") { // Only add valid results
                    tempNewRuns.push({
                      id: Date.now() + (idCounter++), // Unique ID
                      startNum: num,
                      X: x,
                      Y: y,
                      Z: z,
                      sequence: result.sequence,
                      steps: result.steps,
                      type: result.type,
                    });
                  }
                }
              }
            }
            calculatedRuns.push(...tempNewRuns); // Add all new runs to the end
            renderHistory(); // Re-render the history

            if (tempNewRuns.length === 0) {
                errorMessage.textContent = "No valid sequences generated for the given ranges. Check inputs.";
            } else {
                errorMessage.textContent = ""; // Clear error if successful
            }
        });

        // Event Listeners for color pickers to update global colors and re-render history
        document.getElementById('divColorPicker').addEventListener('input', (e) => {
            window.divColor = e.target.value; // Get the new color from the picker
            renderHistory(); // Re-render all the displayed nets with the new color
        });

        document.getElementById('mulColorPicker').addEventListener('input', (e) => {
            window.mulColor = e.target.value; // Get the new color from the picker
            renderHistory(); // Re-render all the displayed nets with the new color
        });

        // Initial render (on page load)
        document.addEventListener('DOMContentLoaded', () => {
            renderHistory(); // Ensure history container visibility is correctly set on load
        });
    
    </script>
</body>
</html>