<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2D Pseudo-3D Slicer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start; /* Align to top to give space for controls */
            min-height: 100vh;
            background-color: #1a202c; /* Dark background similar to index.html */
            color: #e2e8f0; /* Light text color */
            padding: 1rem;
            box-sizing: border-box;
        }
        .container {
            background-color: #2d3748; /* Slightly lighter dark background for container */
            padding: 2rem;
            border-radius: 0.75rem; /* rounded-xl */
            box-shadow: 0 10px 15px rgba(0, 0, 0, 0.2); /* shadow-xl */
            text-align: center;
            max-width: 90%; /* Responsive width */
            margin-bottom: 2rem;
            width: 100%; /* Ensure it takes full width up to max-width */
        }
        /* Adjusted canvas styling for consistency across the app */
        canvas {
            display: block;
            margin: 1.5rem auto; /* mt-6 mb-6 */
            border-radius: 0.5rem; /* rounded-md */
            border: 1px solid #4a5568; /* border-gray-600 */
            max-width: 100%; /* Ensure canvas is responsive */
            height: auto; /* Maintain aspect ratio */
        }
        .param-display {
            font-size: 1.25rem; /* text-xl */
            font-weight: 600; /* font-semibold */
            margin-bottom: 1rem;
            color: #90cdf4; /* blue-300 */
        }
        .sequence-info {
            font-size: 1rem; /* text-base */
            margin-bottom: 1.5rem;
            color: #a0aec0; /* gray-400 */
        }
        .sequence-numbers {
            background-color: #1a202c; /* Darker background for sequence numbers */
            padding: 0.75rem;
            border-radius: 0.375rem; /* rounded-md */
            max-height: 8rem; /* max-h-32 */
            overflow-y: auto;
            font-size: 0.875rem; /* text-sm */
            word-break: break-all;
            color: #cbd5e0; /* gray-300 */
            margin-bottom: 1.5rem;
        }
        .color-display {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 1rem;
            margin-top: 1rem;
        }
        .color-box {
            width: 1.5rem;
            height: 1.5rem;
            border-radius: 0.25rem;
            border: 1px solid #a0aec0;
        }
        /* Styles for slideshow controls */
        .slideshow-controls {
            display: flex;
            flex-wrap: wrap;
            gap: 1rem;
            justify-content: center;
            align-items: center;
            margin-top: 1.5rem;
            padding: 1rem;
            background-color: #2d3748;
            border-radius: 0.75rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        .slideshow-controls label {
            color: #e2e8f0;
            font-weight: 600;
        }
        .slideshow-controls select,
        .slideshow-controls input[type="range"],
        .slideshow-controls input[type="number"] { /* Added number input styling */
            background-color: #4a5568;
            border: 1px solid #64748b;
            color: #e2e8f0;
            padding: 0.5rem;
            border-radius: 0.5rem;
        }
        .slideshow-controls button {
            padding: 0.75rem 1.5rem;
            background-color: #4299e1; /* Blue for play/stop */
            color: white;
            font-weight: bold;
            border-radius: 0.75rem;
            transition: background-color 0.3s ease;
        }
        .slideshow-controls button:hover {
            background-color: #3182ce;
        }
        /* Styles for the grid of 9-nets */
        .grid-container {
            display: grid;
            /* Calculate minmax based on desired display size, maintaining aspect ratio */
            grid-template-columns: repeat(auto-fill, minmax(180px, 1fr)); /* Adjusted for better fit */
            gap: 1.5rem;
            padding: 1rem;
            width: 100%;
            max-width: 1200px; /* Limit overall grid width */
            margin: 2rem auto;
            background-color: #2d3748;
            border-radius: 0.75rem;
            box-shadow: 0 10px 15px rgba(0, 0, 0, 0.2);
        }
        .grid-item {
            background-color: #1a202c;
            padding: 1rem;
            border-radius: 0.5rem;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            text-align: center;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: space-between; /* Distribute space */
        }
        .grid-item canvas {
            /* Set max-width to a desired display size, height auto to maintain aspect ratio */
            max-width: 150px; /* Display size for grid items */
            height: auto; /* Crucial for maintaining aspect ratio */
            margin: 0.5rem auto;
            border: 1px solid #4a5568;
        }
        .grid-item .info {
            font-size: 0.875rem;
            color: #cbd5e0;
            margin-bottom: 0.5rem;
        }
        .grid-item button {
            background-color: #61dafb; /* Light blue for "View in Main" */
            color: #1a202c;
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            font-weight: bold;
            transition: background-color 0.3s ease;
            margin-top: 0.5rem;
        }
        .grid-item button:hover {
            background-color: #21a1f1;
        }
        /* Custom styling for the gold star/indicator */
        .gold-star {
            color: gold; /* Or use an emoji like '⭐' in the HTML directly */
            font-size: 1.25rem; /* text-xl */
            margin-left: 0.25rem; /* ml-1 */
            display: inline-block; /* To align with text */
        }
    </style>
</head>
<body>
    <div class="container">
        <h1 class="text-3xl font-bold mb-4">2D Pseudo-3D Slicer</h1>
        <p class="param-display" id="paramDisplay">Loading parameters...</p>
        <p class="sequence-info" id="sequenceInfo">Calculating sequence...</p>
        <p class="sequence-range-info text-gray-400 text-sm mb-2" id="sequenceRangeInfo"></p>
        <p class="sequence-sum-info text-gray-400 text-sm mb-2" id="sequenceSumInfo"></p>
        <p class="sequence-avg-info text-gray-400 text-sm mb-2" id="sequenceAvgInfo"></p>
        <p class="sequence-stddev-info text-gray-400 text-sm mb-2" id="sequenceStdDevInfo"></p>
        <div class="sequence-numbers" id="sequenceNumbers"></div>

        <canvas id="nineNetCanvas" width="380" height="290"></canvas>

        <div class="color-display">
            <span class="text-lg">Divisible:</span>
            <div id="divColorBox" class="color-box"></div>
            <span class="text-lg">Multiply/Add:</span>
            <div id="mulColorBox" class="color-box"></div>
        </div>

        <button onclick="window.close()" class="mt-6 px-6 py-3 bg-red-600 hover:bg-red-700 text-white font-bold rounded-xl shadow-lg transform transition duration-300 ease-in-out hover:scale-105 focus:outline-none focus:ring-2 focus:ring-red-400">
            Close Slicer
        </button>
    </div>

    <div class="container slideshow-controls">
        <div class="flex flex-col items-center">
            <label for="animationAxis">Animate Axis:</label>
            <select id="animationAxis" class="mt-1 p-2 rounded-md">
                <option value="N">N (Start Number)</option>
                <option value="X">X (Divisor)</option>
                <option value="Y">Y (Multiplier)</option>
                <option value="Z">Z (Adder)</option>
            </select>
        </div>
        <div class="flex flex-col items-center">
            <label for="animationSpeed">Speed (ms/step):</label>
            <input type="range" id="animationSpeed" min="50" max="2000" value="500" class="mt-1">
            <span id="speedValue" class="text-sm text-gray-400">500</span>
        </div>
        <button id="toggleSlideshow" class="px-4 py-2">Play Slideshow</button>

        <div class="flex flex-col items-center">
            <label class="flex items-center gap-2">N Range:
                <span id="n-star" class="gold-star hidden">⭐</span>
            </label>
            <div class="flex gap-2">
                <input type="number" id="nMin" value="1" min="1" class="w-20 p-2 rounded-md text-center">
                <input type="number" id="nMax" value="50" min="1" class="w-20 p-2 rounded-md text-center">
            </div>
        </div>
        <div class="flex flex-col items-center">
            <label class="flex items-center gap-2">X Range:
                <span id="x-star" class="gold-star hidden">⭐</span>
            </label>
            <div class="flex gap-2">
                <input type="number" id="xMin" value="2" min="1" class="w-20 p-2 rounded-md text-center">
                <input type="number" id="xMax" value="5" min="1" class="w-20 p-2 rounded-md text-center">
            </div>
        </div>
        <div class="flex flex-col items-center">
            <label class="flex items-center gap-2">Y Range:
                <span id="y-star" class="gold-star hidden">⭐</span>
            </label>
            <div class="flex gap-2">
                <input type="number" id="yMin" value="3" min="1" class="w-20 p-2 rounded-md text-center">
                <input type="number" id="yMax" value="5" min="1" class="w-20 p-2 rounded-md text-center">
            </div>
        </div>
        <div class="flex flex-col items-center">
            <label class="flex items-center gap-2">Z Range:
                <span id="z-star" class="gold-star hidden">⭐</span>
            </label>
            <div class="flex gap-2">
                <input type="number" id="zMin" value="1" min="1" class="w-20 p-2 rounded-md text-center">
                <input type="number" id="zMax" value="5" min="1" class="w-20 p-2 rounded-md text-center">
            </div>
        </div>
        <button id="applyFilters" class="px-4 py-2 bg-green-500 hover:bg-green-600">Apply Filters</button>
    </div>

    <div id="gridContainer" class="grid-container">
        </div>

    <script type="module">
        // Import functions and constants from utils.js
        import {
            calculateCollatzSequence, // Renamed from generalizedCollatz
            drawNineNetCanvasSecondary,
            getUrlParams,
            DEFAULT_LINE_COLOR, // For divColor
            DEFAULT_NODE_COLOR, // For mulColor
            FACE_SIZE,
            PADDING,
            STEP_SIZE,
            NINE_NET_DRAW_WIDTH,
            NINE_NET_DRAW_HEIGHT,
            isLight // Helper for text color
        } from './utils.js';


        // === Slideshow Animation Logic ===
        let slideshowInterval;
        let isSlideshowPlaying = false;
        let currentAnimationValue;
        let allBoxUniverses = []; // Stores all generated universes for bulk display/slideshow
        let filteredBoxUniverses = []; // Currently displayed universes (if filtering was applied)
        const MAX_ITERATIONS = 1000; // Max iterations for sequence calculation

        // Default colors for the 9-net drawing from utils.js
        const divColor = DEFAULT_LINE_COLOR;
        const mulColor = DEFAULT_NODE_COLOR;


        // Get elements for controls
        const animationAxisSelect = document.getElementById('animationAxis');
        const animationSpeedSlider = document.getElementById('animationSpeed');
        const speedValueSpan = document.getElementById('speedValue');
        const toggleSlideshowButton = document.getElementById('toggleSlideshow');
        const nMinInput = document.getElementById('nMin');
        const nMaxInput = document.getElementById('nMax');
        const xMinInput = document.getElementById('xMin');
        const xMaxInput = document.getElementById('xMax');
        const yMinInput = document.getElementById('yMin');
        const yMaxInput = document.getElementById('yMax');
        const zMinInput = document.getElementById('zMin');
        const zMaxInput = document.getElementById('zMax');
        const applyFiltersButton = document.getElementById('applyFilters');
        const gridContainer = document.getElementById('gridContainer');
        const nineNetCanvas = document.getElementById('nineNetCanvas'); // Main display canvas
        const paramDisplay = document.getElementById('paramDisplay'); // Main display text
        const sequenceInfo = document.getElementById('sequenceInfo'); // Main display text
        const sequenceNumbersDiv = document.getElementById('sequenceNumbers'); // Main display sequence numbers
        const sequenceRangeInfo = document.getElementById('sequenceRangeInfo'); // New element for main slicer display
        const sequenceSumInfo = document.getElementById('sequenceSumInfo'); // New element for main slicer display
        const sequenceAvgInfo = document.getElementById('sequenceAvgInfo'); // New element for main slicer display
        const sequenceStdDevInfo = document.getElementById('sequenceStdDevInfo'); // New element for main slicer display

        // Gold star elements for slicer
        const nStarSlicer = document.getElementById('n-star');
        const xStarSlicer = document.getElementById('x-star');
        const yStarSlicer = document.getElementById('y-star');
        const zStarSlicer = document.getElementById('z-star');


        // Update speed value display
        if (animationSpeedSlider && speedValueSpan) { // Add null checks
            animationSpeedSlider.addEventListener('input', () => {
                speedValueSpan.textContent = animationSpeedSlider.value;
            });
        }

        // Function to toggle slideshow playback
        if (toggleSlideshowButton) { // Add null check
            toggleSlideshowButton.addEventListener('click', () => {
                if (isSlideshowPlaying) {
                    clearInterval(slideshowInterval);
                    toggleSlideshowButton.textContent = 'Play Slideshow';
                    isSlideshowPlaying = false;
                } else {
                    // Before starting, make sure we have universes to cycle through
                    if (filteredBoxUniverses.length === 0) {
                        applyAndDrawFilters(); // Generate if not already present
                        if (filteredBoxUniverses.length === 0) {
                            // Still no universes, show an error or message
                            console.warn("No universes to play slideshow with. Adjust filter ranges.");
                            return;
                        }
                    }

                    toggleSlideshowButton.textContent = 'Stop Slideshow';
                    isSlideshowPlaying = true;

                    const axis = animationAxisSelect.value;
                    // Initialize currentAnimationValue to the min of the selected axis
                    if (axis === 'N') {
                        currentAnimationValue = parseInt(nMinInput.value);
                    } else if (axis === 'X') {
                        currentAnimationValue = parseInt(xMinInput.value);
                    } else if (axis === 'Y') {
                        currentAnimationValue = parseInt(yMinInput.value);
                    } else if (axis === 'Z') {
                        currentAnimationValue = parseInt(zMinInput.value);
                    } else {
                        currentAnimationValue = 0; // Fallback
                    }

                    animationStep(); // Call the animation step immediately to draw the first frame
                    slideshowInterval = setInterval(animationStep, parseInt(animationSpeedSlider.value));
                }
            });
        }

        // Function to perform one step of the animation
        function animationStep() {
            const axis = animationAxisSelect.value;
            let minVal, maxVal, inputElement;

            if (axis === 'N') {
                minVal = nMinInput ? parseInt(nMinInput.value) : 1;
                maxVal = nMaxInput ? parseInt(nMaxInput.value) : 50;
                inputElement = nMinInput;
            } else if (axis === 'X') {
                minVal = xMinInput ? parseInt(xMinInput.value) : 1;
                maxVal = xMaxInput ? parseInt(xMaxInput.value) : 5;
                inputElement = xMinInput;
            } else if (axis === 'Y') {
                minVal = yMinInput ? parseInt(yMinInput.value) : 1;
                maxVal = yMaxInput ? parseInt(yMaxInput.value) : 5;
                inputElement = yMinInput;
            } else if (axis === 'Z') {
                minVal = zMinInput ? parseInt(zMinInput.value) : 1;
                maxVal = zMaxInput ? parseInt(zMaxInput.value) : 5;
                inputElement = zMinInput;
            }

            currentAnimationValue++;

            if (inputElement && currentAnimationValue > maxVal) {
                currentAnimationValue = minVal;
            }

            if (inputElement) inputElement.value = currentAnimationValue;
            applyAndDrawFilters();
            updateGoldStarVisibilitySlicer(); // Update stars after input changes via animation
        }

        // Function to generate a set of Box Universes based on specified ranges
        function generateBoxUniverses(nMin, nMax, xMin, xMax, yMin, yMax, zMin, zMax) {
            const tempUniverses = [];
            const maxUniversesToGenerate = 100; // Limit to prevent performance issues
            let generatedCount = 0;

            for (let n = nMin; n <= nMax && generatedCount < maxUniversesToGenerate; n++) {
                for (let x = xMin; x <= xMax && generatedCount < maxUniversesToGenerate; x++) {
                    if (x === 0) continue;
                    for (let y = yMin; y <= yMax && generatedCount < maxUniversesToGenerate; y++) {
                        for (let z = zMin; z <= zMax && generatedCount < maxUniversesToGenerate; z++) {
                            const result = calculateCollatzSequence(n, MAX_ITERATIONS, x, y, z); // Use calculateCollatzSequence
                            if (result.type !== "error" && result.type !== "Invalid Parameters (X is 0)") { // Ensure valid parameters
                                tempUniverses.push({
                                    N: n, X: x, Y: y, Z: z,
                                    sequence: result.sequence,
                                    steps: result.steps,
                                    type: result.type,
                                    minVal: result.minVal,
                                    maxVal: result.maxVal,
                                    sumVal: result.sumVal,
                                    avgVal: result.avgVal,
                                    stdDev: result.stdDev,
                                    finalNum: result.sequence[result.sequence.length -1] // Add finalNum for display
                                });
                                generatedCount++;
                            }
                        }
                    }
                }
            }
            return tempUniverses;
        }

        // Function to get current filter values from inputs
        function getFilterValues() {
            // Add null checks for all input elements before accessing their values
            return {
                nMin: nMinInput ? parseInt(nMinInput.value) || 1 : 1,
                nMax: nMaxInput ? parseInt(nMaxInput.value) || 50 : 50,
                xMin: xMinInput ? parseInt(xMinInput.value) || 1 : 1,
                xMax: xMaxInput ? parseInt(xMaxInput.value) || 5 : 5,
                yMin: yMinInput ? parseInt(yMinInput.value) || 1 : 1,
                yMax: yMaxInput ? parseInt(yMaxInput.value) || 5 : 5,
                zMin: zMinInput ? parseInt(zMinInput.value) || 1 : 1,
                zMax: zMaxInput ? parseInt(zMaxInput.value) || 5 : 5
            };
        }

        // Function to display a specific universe in the main view
        function displayMainUniverse(universe) {
            if (!paramDisplay || !sequenceInfo || !sequenceNumbersDiv || !sequenceRangeInfo || !sequenceSumInfo || !sequenceAvgInfo || !sequenceStdDevInfo || !nineNetCanvas) {
                console.error("Missing one or more main display elements for displayMainUniverse.");
                return;
            }

            paramDisplay.textContent = `N=${universe.N}, X=${universe.X}, Y=${universe.Y}, Z=${universe.Z}`;
            let typeText = universe.type.replace(/_/g, ' ');
            if (universe.type === "Cycle Detected") { // Updated for exact match
                typeText += ` (Cycle: ${universe.sequence[universe.sequence.indexOf(universe.finalNum)].toLocaleString()} → ...)`; // Show cycle start
            } else if (universe.type === "Max Iterations Reached" || universe.type === "Exceeded Max Safe Integer") { // Updated for exact match
                typeText += ` (Final: ${universe.finalNum !== undefined ? universe.finalNum.toLocaleString() : 'N/A'})`; // Added undefined check
            } else if (universe.type === "Converges to 1") { // Updated for exact match
                 typeText += ` (Final: 1)`;
            }
            sequenceInfo.textContent = `Steps: ${universe.steps} | Type: ${typeText}`;
            sequenceNumbersDiv.textContent = universe.sequence.join(' → ');

            // Display statistics
            sequenceRangeInfo.textContent = `Range: [${universe.minVal.toLocaleString()}, ${universe.maxVal.toLocaleString()}]`;
            // Check if sumVal is a safe number or if it's "Too Large" (from calculateCollatzSequence)
            sequenceSumInfo.textContent = `Sum: ${typeof universe.sumVal === 'number' && Number.isFinite(universe.sumVal) ? universe.sumVal.toLocaleString() : 'Too Large'}`;
            sequenceAvgInfo.textContent = `Avg: ${typeof universe.avgVal === 'number' && Number.isFinite(universe.avgVal) ? universe.avgVal.toLocaleString(undefined, { maximumFractionDigits: 2 }) : 'N/A'}`;
            sequenceStdDevInfo.textContent = `StdDev: ${typeof universe.stdDev === 'number' && Number.isFinite(universe.stdDev) ? universe.stdDev.toLocaleString(undefined, { maximumFractionDigits: 2 }) : 'N/A'}`;


            drawNineNetCanvasSecondary(nineNetCanvas, universe.sequence, universe.X, divColor, mulColor);
            nineNetCanvas.style.display = 'block'; // Ensure canvas is visible when displaying a universe
        }


        // Function to apply filters and draw the grid of universes
        function applyAndDrawFilters() {
            const filters = getFilterValues();
            filteredBoxUniverses = generateBoxUniverses(
                filters.nMin, filters.nMax,
                filters.xMin, filters.xMax,
                filters.yMin, filters.yMax,
                filters.zMin, filters.zMax
            );

            if (!gridContainer) {
                console.error("Grid container not found. Cannot apply filters.");
                return;
            }
            gridContainer.innerHTML = ''; // Clear existing grid items

            if (filteredBoxUniverses.length === 0) {
                gridContainer.innerHTML = '<p class="text-gray-400 text-center col-span-full">No universes found for the given ranges. Try adjusting the filters.</p>';
                // Clear main display if no universes are found for filtered view
                if (paramDisplay) paramDisplay.textContent = 'No specific sequence loaded. Use controls below.';
                if (sequenceInfo) sequenceInfo.textContent = '';
                if (sequenceNumbersDiv) sequenceNumbersDiv.textContent = '';
                if (nineNetCanvas) nineNetCanvas.getContext('2d').clearRect(0, 0, nineNetCanvas.width, nineNetCanvas.height);
                if (sequenceRangeInfo) sequenceRangeInfo.textContent = '';
                if (sequenceSumInfo) sequenceSumInfo.textContent = '';
                if (sequenceAvgInfo) sequenceAvgInfo.textContent = '';
                if (sequenceStdDevInfo) sequenceStdDevInfo.textContent = '';
                if (nineNetCanvas) nineNetCanvas.style.display = 'none'; // Hide main canvas on error
                return;
            }

            // Display the first universe in the main canvas if it's the initial load or filters changed
            const urlParams = getUrlParams();
            const urlN = parseInt(urlParams.n);
            const urlX = parseInt(urlParams.x);
            const urlY = parseInt(urlParams.y);
            const urlZ = parseInt(urlParams.z);

            const isUrlLoaded = !isNaN(urlN) && !isNaN(urlX) && !isNaN(urlY) && !isNaN(urlZ);
            let updateMainDisplay = true;

            if (isUrlLoaded) {
                const currentMainUniverse = { N: urlN, X: urlX, Y: urlY, Z: urlZ };
                const isStillInFilter = filteredBoxUniverses.some(u =>
                    u.N === currentMainUniverse.N &&
                    u.X === currentMainUniverse.X &&
                    u.Y === currentMainUniverse.Y &&
                    u.Z === currentMainUniverse.Z
                );
                if (isStillInFilter) {
                    // Find the exact universe object that matches the URL params
                    const exactMatch = filteredBoxUniverses.find(u =>
                        u.N === currentMainUniverse.N &&
                        u.X === currentMainUniverse.X &&
                        u.Y === currentMainUniverse.Y &&
                        u.Z === currentMainUniverse.Z
                    );
                    if (exactMatch) {
                        displayMainUniverse(exactMatch);
                        updateMainDisplay = false;
                    }
                }
            }

            if (updateMainDisplay && filteredBoxUniverses.length > 0) {
                displayMainUniverse(filteredBoxUniverses[0]);
            }


            filteredBoxUniverses.forEach(universe => {
                const gridItem = document.createElement('div');
                gridItem.className = 'grid-item';

                const canvasElement = document.createElement('canvas');
                canvasElement.width = NINE_NET_DRAW_WIDTH;
                canvasElement.height = NINE_NET_DRAW_HEIGHT;
                canvasElement.className = 'grid-item-canvas';

                drawNineNetCanvasSecondary(canvasElement, universe.sequence, universe.X, divColor, mulColor);

                const infoDiv = document.createElement('div');
                infoDiv.className = 'info';
                infoDiv.innerHTML = `N=${universe.N}, X=${universe.X}, Y=${universe.Y}, Z=${universe.Z}<br>`;
                let typeText = universe.type.replace(/_/g, ' ');

                if (universe.type === "Cycle Detected") {
                    typeText += ` (Cycle)`;
                } else if (universe.type === "Max Iterations Reached" || universe.type === "Exceeded Max Safe Integer") {
                    typeText += ` (Final: ${universe.finalNum !== undefined ? universe.finalNum.toLocaleString() : 'N/A'})`;
                }
                infoDiv.innerHTML += `Steps: ${universe.steps} | Type: ${typeText}`;
                infoDiv.innerHTML += `<br>Range: [${universe.minVal.toLocaleString()}, ${universe.maxVal.toLocaleString()}]`;
                infoDiv.innerHTML += `<br>Sum: ${typeof universe.sumVal === 'number' && Number.isFinite(universe.sumVal) ? universe.sumVal.toLocaleString() : 'Too Large'}`;
                infoDiv.innerHTML += `<br>Avg: ${typeof universe.avgVal === 'number' && Number.isFinite(universe.avgVal) ? universe.avgVal.toLocaleString(undefined, { maximumFractionDigits: 2 }) : 'N/A'}`;
                infoDiv.innerHTML += `<br>StdDev: ${typeof universe.stdDev === 'number' && Number.isFinite(universe.stdDev) ? universe.stdDev.toLocaleString(undefined, { maximumFractionDigits: 2 }) : 'N/A'}`;


                const viewButton = document.createElement('button');
                viewButton.textContent = 'View in Main';
                viewButton.addEventListener('click', () => {
                    displayMainUniverse(universe);
                });

                gridItem.appendChild(canvasElement);
                gridItem.appendChild(infoDiv);
                gridItem.appendChild(viewButton);
                gridContainer.appendChild(gridItem);
            });

            updateGoldStarVisibilitySlicer();
        }

        // Function to update the gold star visibility in Slicer
        function updateGoldStarVisibilitySlicer() {
            // Ensure inputs exist before trying to read their values
            const xVal = xMinInput ? parseInt(xMinInput.value) : NaN;
            const yVal = yMinInput ? parseInt(yMinInput.value) : NaN;
            const zVal = zMinInput ? parseInt(zMinInput.value) : NaN;

            // The gold star should only appear when X=2, Y=3, and Z=1 (standard Collatz parameters)
            // based on the minimum values of the ranges.
            if (xStarSlicer) xStarSlicer.style.display = (xVal === 2 && xMaxInput && parseInt(xMaxInput.value) === 2) ? 'inline-block' : 'none';
            if (yStarSlicer) yStarSlicer.style.display = (yVal === 3 && yMaxInput && parseInt(yMaxInput.value) === 3) ? 'inline-block' : 'none';
            if (zStarSlicer) zStarSlicer.style.display = (zVal === 1 && zMaxInput && parseInt(zMaxInput.value) === 1) ? 'inline-block' : 'none';

            // N-star is always hidden as N doesn't define the rule parameters
            if (nStarSlicer) nStarSlicer.style.display = 'none';
        }


        // Event listener for apply filters button
        if (applyFiltersButton) applyFiltersButton.addEventListener('click', applyAndDrawFilters);

        // Add event listeners to input fields to update gold star visibility
        // These will update the stars as the user types/changes values
        if (nMinInput) nMinInput.addEventListener('input', updateGoldStarVisibilitySlicer);
        if (nMaxInput) nMaxInput.addEventListener('input', updateGoldStarVisibilitySlicer);
        if (xMinInput) xMinInput.addEventListener('input', updateGoldStarVisibilitySlicer);
        if (xMaxInput) xMaxInput.addEventListener('input', updateGoldStarVisibilitySlicer);
        if (yMinInput) yMinInput.addEventListener('input', updateGoldStarVisibilitySlicer);
        if (yMaxInput) yMaxInput.addEventListener('input', updateGoldStarVisibilitySlicer);
        if (zMinInput) zMinInput.addEventListener('input', updateGoldStarVisibilitySlicer);
        if (zMaxInput) zMaxInput.addEventListener('input', updateGoldStarVisibilitySlicer);


        // Initial setup on page load
        window.addEventListener('DOMContentLoaded', () => {
            const params = getUrlParams();
            const n = parseInt(params.n);
            const x = parseInt(params.x);
            const y = parseInt(params.y);
            const z = parseInt(params.z);

            // Update color boxes based on initial values (defaults or URL)
            const divColorBox = document.getElementById('divColorBox');
            const mulColorBox = document.getElementById('mulColorBox');
            if (divColorBox) divColorBox.style.backgroundColor = divColor;
            if (mulColorBox) mulColorBox.style.backgroundColor = mulColor;

            // If URL parameters are present, pre-fill inputs and display that single universe in the main canvas
            if (!isNaN(n) && !isNaN(x) && !isNaN(y) && !isNaN(z)) {
                // Set current animation values to URL values if they were provided
                if (nMinInput) nMinInput.value = n;
                if (nMaxInput) nMaxInput.value = n; // Set max to N to ensure it stays in range
                if (xMinInput) xMinInput.value = x;
                if (xMaxInput) xMaxInput.value = x;
                if (yMinInput) yMinInput.value = y;
                if (yMaxInput) yMaxInput.value = y;
                if (zMinInput) zMinInput.value = z;
                if (zMaxInput) zMaxInput.value = z;

                const result = calculateCollatzSequence(n, MAX_ITERATIONS, x, y, z); // Use calculateCollatzSequence
                if (result.type !== "error" && result.type !== "Invalid Parameters (X is 0)") {
                    displayMainUniverse({ N: n, X: x, Y: y, Z: z, ...result });
                    if (nineNetCanvas) nineNetCanvas.style.display = 'block'; // Ensure main canvas is visible
                } else {
                    // Handle error for URL-loaded sequence
                    if (paramDisplay) paramDisplay.textContent = `Error for N=${n}, X=${x}, Y=${y}, Z=${z}`;
                    if (sequenceInfo) sequenceInfo.textContent = result.type; // Display the error type
                    if (sequenceNumbersDiv) sequenceNumbersDiv.textContent = '';
                    if (nineNetCanvas) nineNetCanvas.getContext('2d').clearRect(0, 0, nineNetCanvas.width, nineNetCanvas.height);
                    if (sequenceRangeInfo) sequenceRangeInfo.textContent = '';
                    if (sequenceSumInfo) sequenceSumInfo.textContent = '';
                    if (sequenceAvgInfo) sequenceAvgInfo.textContent = '';
                    if (sequenceStdDevInfo) sequenceStdDevInfo.textContent = '';
                    if (nineNetCanvas) nineNetCanvas.style.display = 'none'; // Hide main canvas on error
                }
            } else {
                // If no parameters, hide the main canvas initially, then `applyAndDrawFilters` will handle it.
                if (nineNetCanvas) nineNetCanvas.style.display = 'none';
                if (paramDisplay) paramDisplay.textContent = 'No specific sequence loaded. Use controls below.';
                if (sequenceInfo) sequenceInfo.textContent = '';
                if (sequenceNumbersDiv) sequenceNumbersDiv.textContent = '';
                if (sequenceRangeInfo) sequenceRangeInfo.textContent = '';
                if (sequenceSumInfo) sequenceSumInfo.textContent = '';
                if (sequenceAvgInfo) sequenceAvgInfo.textContent = '';
                if (sequenceStdDevInfo) sequenceStdDevInfo.textContent = '';
            }

            // Initial draw of bulk universes (always happens regardless of URL params)
            applyAndDrawFilters(); // This will populate the grid with default ranges and potentially update the main display

            // Adjust canvas size if needed for responsiveness (for the single canvas at the top)
            function resizeMainCanvas() {
                if (!nineNetCanvas || !paramDisplay) {
                    return;
                }
                const containerWidth = nineNetCanvas.parentElement ? nineNetCanvas.parentElement.clientWidth : NINE_NET_DRAW_WIDTH;
                const desiredDisplayWidth = Math.min(containerWidth * 0.9, NINE_NET_DRAW_WIDTH);
                nineNetCanvas.style.width = `${desiredDisplayWidth}px`;
                nineNetCanvas.style.height = 'auto';

                // Redraw if there's currently a sequence displayed and canvas is visible
                const currentParamsText = paramDisplay.textContent;
                const nMatch = currentParamsText.match(/N=(\d+)/);
                const xMatch = currentParamsText.match(/X=(\d+)/);
                const yMatch = currentParamsText.match(/Y=(\d+)/);
                const zMatch = currentParamsText.match(/Z=(\d+)/);

                const currentN = nMatch ? parseInt(nMatch[1]) : NaN;
                const currentX = xMatch ? parseInt(xMatch[1]) : NaN;
                const currentY = yMatch ? parseInt(yMatch[1]) : NaN;
                const currentZ = zMatch ? parseInt(zMatch[1]) : NaN;

                if (!isNaN(currentN) && !isNaN(currentX) && !isNaN(currentY) && !isNaN(currentZ) && nineNetCanvas.style.display !== 'none') {
                    const result = calculateCollatzSequence(currentN, MAX_ITERATIONS, currentX, currentY, currentZ);
                    if (result.type !== "error" && result.type !== "Invalid Parameters (X is 0)") {
                        drawNineNetCanvasSecondary(nineNetCanvas, result.sequence, currentX, divColor, mulColor);
                    }
                }
            }
            window.addEventListener('resize', resizeMainCanvas);
            resizeMainCanvas();
            updateGoldStarVisibilitySlicer();
        });
    </script>
</body>
</html>
