<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2D Pseudo-3D Slicer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start; /* Align to top to give space for controls */
            min-height: 100vh;
            background-color: #1a202c; /* Dark background similar to index.html */
            color: #e2e8f0; /* Light text color */
            padding: 1rem;
            box-sizing: border-box;
        }
        .container {
            background-color: #2d3748; /* Slightly lighter dark background for container */
            padding: 2rem;
            border-radius: 0.75rem; /* rounded-xl */
            box-shadow: 0 10px 15px rgba(0, 0, 0, 0.2); /* shadow-xl */
            text-align: center;
            max-width: 90%; /* Responsive width */
            margin-bottom: 2rem;
            width: 100%; /* Ensure it takes full width up to max-width */
        }
        /* Adjusted canvas styling for consistency across the app */
        canvas {
            display: block;
            margin: 1.5rem auto; /* mt-6 mb-6 */
            border-radius: 0.5rem; /* rounded-md */
            border: 1px solid #4a5568; /* border-gray-600 */
            max-width: 100%; /* Ensure canvas is responsive */
            height: auto; /* Maintain aspect ratio */
        }
        .param-display {
            font-size: 1.25rem; /* text-xl */
            font-weight: 600; /* font-semibold */
            margin-bottom: 1rem;
            color: #90cdf4; /* blue-300 */
        }
        .sequence-info {
            font-size: 1rem; /* text-base */
            margin-bottom: 1.5rem;
            color: #a0aec0; /* gray-400 */
        }
        .sequence-numbers {
            background-color: #1a202c; /* Darker background for sequence numbers */
            padding: 0.75rem;
            border-radius: 0.375rem; /* rounded-md */
            max-height: 8rem; /* max-h-32 */
            overflow-y: auto;
            font-size: 0.875rem; /* text-sm */
            word-break: break-all;
            color: #cbd5e0; /* gray-300 */
            margin-bottom: 1.5rem;
        }
        .color-display {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 1rem;
            margin-top: 1rem;
        }
        .color-box {
            width: 1.5rem;
            height: 1.5rem;
            border-radius: 0.25rem;
            border: 1px solid #a0aec0;
        }
        /* Styles for slideshow controls */
        .slideshow-controls {
            display: flex;
            flex-wrap: wrap;
            gap: 1rem;
            justify-content: center;
            align-items: center;
            margin-top: 1.5rem;
            padding: 1rem;
            background-color: #2d3748;
            border-radius: 0.75rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        .slideshow-controls label {
            color: #e2e8f0;
            font-weight: 600;
        }
        .slideshow-controls select,
        .slideshow-controls input[type="range"],
        .slideshow-controls input[type="number"] { /* Added number input styling */
            background-color: #4a5568;
            border: 1px solid #64748b;
            color: #e2e8f0;
            padding: 0.5rem;
            border-radius: 0.5rem;
        }
        .slideshow-controls button {
            padding: 0.75rem 1.5rem;
            background-color: #4299e1; /* Blue for play/stop */
            color: white;
            font-weight: bold;
            border-radius: 0.75rem;
            transition: background-color 0.3s ease;
        }
        .slideshow-controls button:hover {
            background-color: #3182ce;
        }
        /* Styles for the grid of 9-nets */
        .grid-container {
            display: grid;
            /* Calculate minmax based on desired display size, maintaining aspect ratio */
            grid-template-columns: repeat(auto-fill, minmax(180px, 1fr)); /* Adjusted for better fit */
            gap: 1.5rem;
            padding: 1rem;
            width: 100%;
            max-width: 1200px; /* Limit overall grid width */
            margin: 2rem auto;
            background-color: #2d3748;
            border-radius: 0.75rem;
            box-shadow: 0 10px 15px rgba(0, 0, 0, 0.2);
        }
        .grid-item {
            background-color: #1a202c;
            padding: 1rem;
            border-radius: 0.5rem;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            text-align: center;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: space-between; /* Distribute space */
        }
        .grid-item canvas {
            /* Set max-width to a desired display size, height auto to maintain aspect ratio */
            max-width: 150px; /* Display size for grid items */
            height: auto; /* Crucial for maintaining aspect ratio */
            margin: 0.5rem auto;
            border: 1px solid #4a5568;
        }
        .grid-item .info {
            font-size: 0.875rem;
            color: #cbd5e0;
            margin-bottom: 0.5rem;
        }
        .grid-item button {
            background-color: #61dafb; /* Light blue for "View in Main" */
            color: #1a202c;
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            font-weight: bold;
            transition: background-color 0.3s ease;
            margin-top: 0.5rem;
        }
        .grid-item button:hover {
            background-color: #21a1f1;
        }
        /* Custom styling for the gold star/indicator */
        .gold-star {
            color: gold; /* Or use an emoji like '⭐' in the HTML directly */
            font-size: 1.25rem; /* text-xl */
            margin-left: 0.25rem; /* ml-1 */
            display: inline-block; /* To align with text */
        }
    </style>
</head>
<body>
    <div class="container">
        <h1 class="text-3xl font-bold mb-4">2D Pseudo-3D Slicer</h1>
        <p class="param-display" id="paramDisplay">Loading parameters...</p>
        <p class="sequence-info" id="sequenceInfo">Calculating sequence...</p>
        <p class="sequence-range-info text-gray-400 text-sm mb-2" id="sequenceRangeInfo"></p>
        <p class="sequence-sum-info text-gray-400 text-sm mb-2" id="sequenceSumInfo"></p>
        <p class="sequence-avg-info text-gray-400 text-sm mb-2" id="sequenceAvgInfo"></p>
        <p class="sequence-stddev-info text-gray-400 text-sm mb-2" id="sequenceStdDevInfo"></p>
        <div class="sequence-numbers" id="sequenceNumbers"></div>

        <canvas id="nineNetCanvas" width="380" height="290"></canvas>

        <div class="color-display">
            <span class="text-lg">Divisible:</span>
            <div id="divColorBox" class="color-box"></div>
            <span class="text-lg">Multiply/Add:</span>
            <div id="mulColorBox" class="color-box"></div>
        </div>

        <button onclick="window.close()" class="mt-6 px-6 py-3 bg-red-600 hover:bg-red-700 text-white font-bold rounded-xl shadow-lg transform transition duration-300 ease-in-out hover:scale-105 focus:outline-none focus:ring-2 focus:ring-red-400">
            Close Slicer
        </button>
    </div>

    <div class="container slideshow-controls">
        <div class="flex flex-col items-center">
            <label for="animationAxis">Animate Axis:</label>
            <select id="animationAxis" class="mt-1 p-2 rounded-md">
                <option value="N">N (Start Number)</option>
                <option value="X">X (Divisor)</option>
                <option value="Y">Y (Multiplier)</option>
                <option value="Z">Z (Adder)</option>
            </select>
        </div>
        <div class="flex flex-col items-center">
            <label for="animationSpeed">Speed (ms/step):</label>
            <input type="range" id="animationSpeed" min="50" max="2000" value="500" class="mt-1">
            <span id="speedValue" class="text-sm text-gray-400">500</span>
        </div>
        <button id="toggleSlideshow" class="px-4 py-2">Play Slideshow</button>

        <div class="flex flex-col items-center">
            <label class="flex items-center gap-2">N Range:
                <span id="n-star" class="gold-star hidden">⭐</span>
            </label>
            <div class="flex gap-2">
                <input type="number" id="nMin" value="1" min="1" class="w-20 p-2 rounded-md text-center">
                <input type="number" id="nMax" value="50" min="1" class="w-20 p-2 rounded-md text-center">
            </div>
        </div>
        <div class="flex flex-col items-center">
            <label class="flex items-center gap-2">X Range:
                <span id="x-star" class="gold-star hidden">⭐</span>
            </label>
            <div class="flex gap-2">
                <input type="number" id="xMin" value="2" min="1" class="w-20 p-2 rounded-md text-center">
                <input type="number" id="xMax" value="5" min="1" class="w-20 p-2 rounded-md text-center">
            </div>
        </div>
        <div class="flex flex-col items-center">
            <label class="flex items-center gap-2">Y Range:
                <span id="y-star" class="gold-star hidden">⭐</span>
            </label>
            <div class="flex gap-2">
                <input type="number" id="yMin" value="3" min="1" class="w-20 p-2 rounded-md text-center">
                <input type="number" id="yMax" value="5" min="1" class="w-20 p-2 rounded-md text-center">
            </div>
        </div>
        <div class="flex flex-col items-center">
            <label class="flex items-center gap-2">Z Range:
                <span id="z-star" class="gold-star hidden">⭐</span>
            </label>
            <div class="flex gap-2">
                <input type="number" id="zMin" value="1" min="1" class="w-20 p-2 rounded-md text-center">
                <input type="number" id="zMax" value="5" min="1" class="w-20 p-2 rounded-md text-center">
            </div>
        </div>
        <button id="applyFilters" class="px-4 py-2 bg-green-500 hover:bg-green-600">Apply Filters</button>
    </div>

    <div id="gridContainer" class="grid-container">
        </div>

    <script type="module">
    // Import functions and constants from utils.js
    import {
        calculateCollatzSequence, // Renamed from generalizedCollatz
        drawNineNetCanvasSecondary,
        getUrlParams,
        DEFAULT_LINE_COLOR, // For divColor
        DEFAULT_NODE_COLOR, // For mulColor
        FACE_SIZE,
        PADDING,
        STEP_SIZE,
        NINE_NET_DRAW_WIDTH,
        NINE_NET_DRAW_HEIGHT,
        isLight // Helper for text color
    } from './js/utils.js';


    // === Global State Variables ===
    let slideshowInterval;
    let isSlideshowPlaying = false;
    let currentAnimationValue;
    let allBoxUniverses = []; // Stores all generated universes for bulk display/slideshow
    let filteredBoxUniverses = []; // Currently displayed universes (if filtering was applied)
    const MAX_ITERATIONS = 1000; // Max iterations for sequence calculation

    // Default colors for the 9-net drawing from utils.js
    const divColor = DEFAULT_LINE_COLOR;
    const mulColor = DEFAULT_NODE_COLOR;

    // A single function to get all DOM elements.
    function getSlicerElements() {
        return {
            animationAxisSelect: document.getElementById('animationAxis'),
            animationSpeedSlider: document.getElementById('animationSpeed'),
            speedValueSpan: document.getElementById('speedValue'),
            toggleSlideshowButton: document.getElementById('toggleSlideshow'),
            nMinInput: document.getElementById('nMin'),
            nMaxInput: document.getElementById('nMax'),
            xMinInput: document.getElementById('xMin'),
            xMaxInput: document.getElementById('xMax'),
            yMinInput: document.getElementById('yMin'),
            yMaxInput: document.getElementById('yMax'),
            zMinInput: document.getElementById('zMin'),
            zMaxInput: document.getElementById('zMax'),
            applyFiltersButton: document.getElementById('applyFilters'),
            gridContainer: document.getElementById('gridContainer'),
            nineNetCanvas: document.getElementById('nineNetCanvas'), // Main display canvas
            paramDisplay: document.getElementById('paramDisplay'), // Main display text
            sequenceInfo: document.getElementById('sequenceInfo'), // Main display text
            sequenceNumbersDiv: document.getElementById('sequenceNumbers'), // Main display sequence numbers
            sequenceRangeInfo: document.getElementById('sequenceRangeInfo'), // New element for main slicer display
            sequenceSumInfo: document.getElementById('sequenceSumInfo'), // New element for main slicer display
            sequenceAvgInfo: document.getElementById('sequenceAvgInfo'), // New element for main slicer display
            sequenceStdDevInfo: document.getElementById('sequenceStdDevInfo'), // New element for main slicer display

            // Gold star elements for slicer
            nStarSlicer: document.getElementById('n-star'),
            xStarSlicer: document.getElementById('x-star'),
            yStarSlicer: document.getElementById('y-star'),
            zStarSlicer: document.getElementById('z-star'),
        };
    }


    // Update speed value display
    const { animationSpeedSlider, speedValueSpan } = getSlicerElements();
    if (animationSpeedSlider && speedValueSpan) { // Add null checks
        animationSpeedSlider.addEventListener('input', () => {
            speedValueSpan.textContent = animationSpeedSlider.value;
        });
    }

    // Function to toggle slideshow playback
    const elementsForSlideshow = getSlicerElements();
    const { 
        toggleSlideshowButton, 
        animationAxisSelect,
        
    } = getSlicerElements();
    // --- END FIX ---
    if (toggleSlideshowButton) { // Add null check
        toggleSlideshowButton.addEventListener('click', () => {
            const { nMinInput, xMinInput, yMinInput, zMinInput } = getSlicerElements();

            if (isSlideshowPlaying) {
                clearInterval(slideshowInterval);
                toggleSlideshowButton.textContent = 'Play Slideshow';
                isSlideshowPlaying = false;
            } else {
                // Before starting, make sure we have universes to cycle through
                if (filteredBoxUniverses.length === 0) {
                    applyAndDrawFilters(); // Generate if not already present
                    if (filteredBoxUniverses.length === 0) {
                        // Still no universes, show an error or message
                        console.warn("No universes to play slideshow with. Adjust filter ranges.");
                        return;
                    }
                }

                toggleSlideshowButton.textContent = 'Stop Slideshow';
                isSlideshowPlaying = true;

                const axis = animationAxisSelect.value;
                // Initialize currentAnimationValue to the min of the selected axis
                if (axis === 'N') {
                    currentAnimationValue = parseInt(nMinInput.value);
                } else if (axis === 'X') {
                    currentAnimationValue = parseInt(xMinInput.value);
                } else if (axis === 'Y') {
                    currentAnimationValue = parseInt(yMinInput.value);
                } else if (axis === 'Z') {
                    currentAnimationValue = parseInt(zMinInput.value);
                } else {
                    currentAnimationValue = 0; // Fallback
                }

                animationStep(); // Call the animation step immediately to draw the first frame
                slideshowInterval = setInterval(animationStep, parseInt(animationSpeedSlider.value));
            }
        });
    }

    // Function to perform one step of the animation
    function animationStep() {
        const { animationAxisSelect, nMinInput, nMaxInput, xMinInput, xMaxInput, yMinInput, yMaxInput, zMinInput, zMaxInput } = getSlicerElements();
        const axis = animationAxisSelect.value;
        let minVal, maxVal, inputElement;

        if (axis === 'N') {
            minVal = nMinInput ? parseInt(nMinInput.value) : 1;
            maxVal = nMaxInput ? parseInt(nMaxInput.value) : 50;
            inputElement = nMinInput;
        } else if (axis === 'X') {
            minVal = xMinInput ? parseInt(xMinInput.value) : 1;
            maxVal = xMaxInput ? parseInt(xMaxInput.value) : 5;
            inputElement = xMinInput;
        } else if (axis === 'Y') {
            minVal = yMinInput ? parseInt(yMinInput.value) : 1;
            maxVal = yMaxInput ? parseInt(yMaxInput.value) : 5;
            inputElement = yMinInput;
        } else if (axis === 'Z') {
            minVal = zMinInput ? parseInt(zMinInput.value) : 1;
            maxVal = zMaxInput ? parseInt(zMaxInput.value) : 5;
            inputElement = zMinInput;
        }

        currentAnimationValue++;

        if (inputElement && currentAnimationValue > maxVal) {
            currentAnimationValue = minVal;
        }

        if (inputElement) inputElement.value = currentAnimationValue;
        applyAndDrawFilters();
        updateGoldStarVisibilitySlicer(); // Update stars after input changes via animation
    }

    // Function to generate a set of Box Universes based on specified ranges
    function generateBoxUniverses(nMin, nMax, xMin, xMax, yMin, yMax, zMin, zMax) {
        const tempUniverses = [];
        const maxUniversesToGenerate = 100; // Limit to prevent performance issues
        let generatedCount = 0;

        for (let n = nMin; n <= nMax && generatedCount < maxUniversesToGenerate; n++) {
            for (let x = xMin; x <= xMax && generatedCount < maxUniversesToGenerate; x++) {
                if (x === 0) continue;
                for (let y = yMin; y <= yMax && generatedCount < maxUniversesToGenerate; y++) {
                    for (let z = zMin; z <= zMax && generatedCount < maxUniversesToGenerate; z++) {
                        const result = calculateCollatzSequence(n, MAX_ITERATIONS, x, y, z); // Use calculateCollatzSequence
                        if (result.type !== "error" && result.type !== "Invalid Parameters (X is 0)") { // Ensure valid parameters
                            tempUniverses.push({
                                N: n, X: x, Y: y, Z: z,
                                sequence: result.sequence,
                                steps: result.steps,
                                type: result.type,
                                minVal: result.minVal,
                                maxVal: result.maxVal,
                                sumVal: result.sumVal,
                                avgVal: result.avgVal,
                                stdDev: result.stdDev,
                                finalNum: result.sequence[result.sequence.length -1] // Add finalNum for display
                            });
                            generatedCount++;
                        }
                    }
                }
            }
        }
        return tempUniverses;
    }

    // Function to get current filter values from inputs
    function getFilterValues() {
        const { nMinInput, nMaxInput, xMinInput, xMaxInput, yMinInput, yMaxInput, zMinInput, zMaxInput } = getSlicerElements();
        // Add null checks for all input elements before accessing their values
        return {
            nMin: nMinInput ? parseInt(nMinInput.value) || 1 : 1,
            nMax: nMaxInput ? parseInt(nMaxInput.value) || 50 : 50,
            xMin: xMinInput ? parseInt(xMinInput.value) || 1 : 1,
            xMax: xMaxInput ? parseInt(xMaxInput.value) || 5 : 5,
            yMin: yMinInput ? parseInt(yMinInput.value) || 1 : 1,
            yMax: yMaxInput ? parseInt(yMaxInput.value) || 5 : 5,
            zMin: zMinInput ? parseInt(zMinInput.value) || 1 : 1,
            zMax: zMaxInput ? parseInt(zMaxInput.value) || 5 : 5
        };
    }

    // Function to display a specific universe in the main view
    function displayMainUniverse(universe) {
        const { 
            paramDisplay, 
            sequenceInfo, 
            sequenceNumbersDiv, 
            sequenceRangeInfo, 
            sequenceSumInfo, 
            sequenceAvgInfo, 
            sequenceStdDevInfo, 
            nineNetCanvas 
        } = getSlicerElements();

        if (!paramDisplay || !sequenceInfo || !sequenceNumbersDiv || !sequenceRangeInfo || !sequenceSumInfo || !sequenceAvgInfo || !sequenceStdDevInfo || !nineNetCanvas) {
            console.error("Missing one or more main display elements for displayMainUniverse.");
            return;
        }

        paramDisplay.textContent = `N=${universe.N}, X=${universe.X}, Y=${universe.Y}, Z=${universe.Z}`;
        let typeText = universe.type.replace(/_/g, ' ');
        if (universe.type === "Cycle Detected") { 
            typeText += ` (Cycle: ${universe.sequence[universe.sequence.indexOf(universe.finalNum)].toLocaleString()} → ...)`; 
        } else if (universe.type === "Max Iterations Reached" || universe.type === "Exceeded Max Safe Integer") { 
            typeText += ` (Final: ${universe.finalNum !== undefined ? universe.finalNum.toLocaleString() : 'N/A'})`; 
        } else if (universe.type === "Converges to 1") { 
            typeText += ` (Final: 1)`;
        }
        sequenceInfo.textContent = `Steps: ${universe.steps} | Type: ${typeText}`;
        sequenceNumbersDiv.textContent = universe.sequence.join(' → ');

        // Display statistics
        sequenceRangeInfo.textContent = `Range: [${universe.minVal.toLocaleString()}, ${universe.maxVal.toLocaleString()}]`;
        // Check if sumVal is a safe number or if it's "Too Large" (from calculateCollatzSequence)
        sequenceSumInfo.textContent = `Sum: ${typeof universe.sumVal === 'number' && Number.isFinite(universe.sumVal) ? universe.sumVal.toLocaleString() : 'Too Large'}`;
        sequenceAvgInfo.textContent = `Avg: ${typeof universe.avgVal === 'number' && Number.isFinite(universe.avgVal) ? universe.avgVal.toLocaleString(undefined, { maximumFractionDigits: 2 }) : 'N/A'}`;
        sequenceStdDevInfo.textContent = `StdDev: ${typeof universe.stdDev === 'number' && Number.isFinite(universe.stdDev) ? universe.stdDev.toLocaleString(undefined, { maximumFractionDigits: 2 }) : 'N/A'}`;


        drawNineNetCanvasSecondary(nineNetCanvas, universe.sequence, universe.X, divColor, mulColor);
        nineNetCanvas.style.display = 'block'; // Ensure canvas is visible when displaying a universe
    }


    // Function to apply filters and draw the grid of universes
    function applyAndDrawFilters() {
        const { 
            gridContainer, 
            paramDisplay, 
            sequenceInfo, 
            sequenceNumbersDiv, 
            nineNetCanvas, 
            sequenceRangeInfo, 
            sequenceSumInfo, 
            sequenceAvgInfo, 
            sequenceStdDevInfo,
        } = getSlicerElements();

        const filters = getFilterValues();
        filteredBoxUniverses = generateBoxUniverses(
            filters.nMin, filters.nMax,
            filters.xMin, filters.xMax,
            filters.yMin, filters.yMax,
            filters.zMin, filters.zMax
        );

        if (!gridContainer) {
            console.error("Grid container not found. Cannot apply filters.");
            return;
        }
        gridContainer.innerHTML = ''; // Clear existing grid items

        if (filteredBoxUniverses.length === 0) {
            gridContainer.innerHTML = '<p class="text-gray-400 text-center col-span-full">No universes found for the given ranges. Try adjusting the filters.</p>';
            // Clear main display if no universes are found for filtered view
            if (paramDisplay) paramDisplay.textContent = 'No specific sequence loaded. Use controls below.';
            if (sequenceInfo) sequenceInfo.textContent = '';
            if (sequenceNumbersDiv) sequenceNumbersDiv.textContent = '';
            if (nineNetCanvas) nineNetCanvas.getContext('2d').clearRect(0, 0, nineNetCanvas.width, nineNetCanvas.height);
            if (sequenceRangeInfo) sequenceRangeInfo.textContent = '';
            if (sequenceSumInfo) sequenceSumInfo.textContent = '';
            if (sequenceAvgInfo) sequenceAvgInfo.textContent = '';
            if (sequenceStdDevInfo) sequenceStdDevInfo.textContent = '';
            if (nineNetCanvas) nineNetCanvas.style.display = 'none'; // Hide main canvas on error
            return;
        }

        // Display the first universe in the main canvas if it's the initial load or filters changed
        const urlParams = getUrlParams();
        const urlN = parseInt(urlParams.n);
        const urlX = parseInt(urlParams.x);
        const urlY = parseInt(urlParams.y);
        const urlZ = parseInt(urlParams.z);

        const isUrlLoaded = !isNaN(urlN) && !isNaN(urlX) && !isNaN(urlY) && !isNaN(urlZ);
        let updateMainDisplay = true;

        if (isUrlLoaded) {
            const currentMainUniverse = { N: urlN, X: urlX, Y: urlY, Z: urlZ };
            const isStillInFilter = filteredBoxUniverses.some(u =>
                u.N === currentMainUniverse.N &&
                u.X === currentMainUniverse.X &&
                u.Y === currentMainUniverse.Y &&
                u.Z === currentMainUniverse.Z
            );
            if (isStillInFilter) {
                // Find the exact universe object that matches the URL params
                const exactMatch = filteredBoxUniverses.find(u =>
                    u.N === currentMainUniverse.N &&
                    u.X === currentMainUniverse.X &&
                    u.Y === currentMainUniverse.Y &&
                    u.Z === currentMainUniverse.Z
                );
                if (exactMatch) {
                    displayMainUniverse(exactMatch);
                    updateMainDisplay = false;
                }
            }
        }

        if (updateMainDisplay && filteredBoxUniverses.length > 0) {
            displayMainUniverse(filteredBoxUniverses[0]);
        }


        filteredBoxUniverses.forEach(universe => {
            const gridItem = document.createElement('div');
            gridItem.className = 'grid-item';

            const canvasElement = document.createElement('canvas');
            canvasElement.width = NINE_NET_DRAW_WIDTH;
            canvasElement.height = NINE_NET_DRAW_HEIGHT;
            canvasElement.className = 'grid-item-canvas';

            drawNineNetCanvasSecondary(canvasElement, universe.sequence, universe.X, divColor, mulColor);

            const infoDiv = document.createElement('div');
            infoDiv.className = 'info';
            infoDiv.innerHTML = `N=${universe.N}, X=${universe.X}, Y=${universe.Y}, Z=${universe.Z}<br>`;
            let typeText = universe.type.replace(/_/g, ' ');

            if (universe.type === "Cycle Detected") {
                typeText += ` (Cycle)`;
            } else if (universe.type === "Max Iterations Reached" || universe.type === "Exceeded Max Safe Integer") {
                typeText += ` (Final: ${universe.finalNum !== undefined ? universe.finalNum.toLocaleString() : 'N/A'})`;
            }
            infoDiv.innerHTML += `Steps: ${universe.steps} | Type: ${typeText}`;
            infoDiv.innerHTML += `<br>Range: [${universe.minVal.toLocaleString()}, ${universe.maxVal.toLocaleString()}]`;
            infoDiv.innerHTML += `<br>Sum: ${typeof universe.sumVal === 'number' && Number.isFinite(universe.sumVal) ? universe.sumVal.toLocaleString() : 'Too Large'}`;
            infoDiv.innerHTML += `<br>Avg: ${typeof universe.avgVal === 'number' && Number.isFinite(universe.avgVal) ? universe.avgVal.toLocaleString(undefined, { maximumFractionDigits: 2 }) : 'N/A'}`;
            infoDiv.innerHTML += `<br>StdDev: ${typeof universe.stdDev === 'number' && Number.isFinite(universe.stdDev) ? universe.stdDev.toLocaleString(undefined, { maximumFractionDigits: 2 }) : 'N/A'}`;


            const viewButton = document.createElement('button');
            viewButton.textContent = 'View in Main';
            viewButton.addEventListener('click', () => {
                displayMainUniverse(universe);
            });

            gridItem.appendChild(canvasElement);
            gridItem.appendChild(infoDiv);
            gridItem.appendChild(viewButton);
            gridContainer.appendChild(gridItem);
        });

        updateGoldStarVisibilitySlicer();
    }

    // Function to update the gold star visibility in Slicer
    function updateGoldStarVisibilitySlicer() {
        const { 
            xMinInput, xMaxInput, 
            yMinInput, yMaxInput, 
            zMinInput, zMaxInput, 
            nStarSlicer, xStarSlicer, yStarSlicer, zStarSlicer 
        } = getSlicerElements();

        // Ensure inputs exist before trying to read their values
        const xVal = xMinInput ? parseInt(xMinInput.value) : NaN;
        const yVal = yMinInput ? parseInt(yMinInput.value) : NaN;
        const zVal = zMinInput ? parseInt(zMinInput.value) : NaN;

        // The gold star should only appear when X=2, Y=3, and Z=1 (standard Collatz parameters)
        // based on the minimum values of the ranges.
        if (xStarSlicer) xStarSlicer.style.display = (xVal === 2 && xMaxInput && parseInt(xMaxInput.value) === 2) ? 'inline-block' : 'none';
        if (yStarSlicer) yStarSlicer.style.display = (yVal === 3 && yMaxInput && parseInt(yMaxInput.value) === 3) ? 'inline-block' : 'none';
        if (zStarSlicer) zStarSlicer.style.display = (zVal === 1 && zMaxInput && parseInt(zMaxInput.value) === 1) ? 'inline-block' : 'none';

        // N-star is always hidden as N doesn't define the rule parameters
        if (nStarSlicer) nStarSlicer.style.display = 'none';
    }


    const { 
        applyFiltersButton, 
        nMinInput, nMaxInput, 
        xMinInput, xMaxInput, 
        yMinInput, yMaxInput, 
        zMinInput, zMaxInput 
    } = getSlicerElements();

    // Event listener for apply filters button
    if (applyFiltersButton) applyFiltersButton.addEventListener('click', applyAndDrawFilters);

    // Add event listeners to input fields to update gold star visibility
    // These will update the stars as the user types/changes values
    if (nMinInput) nMinInput.addEventListener('input', updateGoldStarVisibilitySlicer);
    if (nMaxInput) nMaxInput.addEventListener('input', updateGoldStarVisibilitySlicer);
    if (xMinInput) xMinInput.addEventListener('input', updateGoldStarVisibilitySlicer);
    if (xMaxInput) xMaxInput.addEventListener('input', updateGoldStarVisibilitySlicer);
    if (yMinInput) yMinInput.addEventListener('input', updateGoldStarVisibilitySlicer);
    if (yMaxInput) yMaxInput.addEventListener('input', updateGoldStarVisibilitySlicer);
    if (zMinInput) zMinInput.addEventListener('input', updateGoldStarVisibilitySlicer);
    if (zMaxInput) zMaxInput.addEventListener('input', updateGoldStarVisibilitySlicer);


    // Initial setup on page load
    window.addEventListener('DOMContentLoaded', () => {
        const {
            nMinInput, nMaxInput, xMinInput, xMaxInput,
            yMinInput, yMaxInput, zMinInput, zMaxInput,
            nineNetCanvas, paramDisplay, sequenceInfo, 
            sequenceNumbersDiv, sequenceRangeInfo, sequenceSumInfo,
            sequenceAvgInfo, sequenceStdDevInfo
        } = getSlicerElements();

        const params = getUrlParams();
        const n = parseInt(params.n);
        const x = parseInt(params.x);
        const y = parseInt(params.y);
        const z = parseInt(params.z);

        // Update color boxes based on initial values (defaults or URL)
        const divColorBox = document.getElementById('divColorBox');
        const mulColorBox = document.getElementById('mulColorBox');
        if (divColorBox) divColorBox.style.backgroundColor = divColor;
        if (mulColorBox) mulColorBox.style.backgroundColor = mulColor;

        // If URL parameters are present, pre-fill inputs and display that single universe in the main canvas
        if (!isNaN(n) && !isNaN(x) && !isNaN(y) && !isNaN(z)) {
            // Set current animation values to URL values if they were provided
            if (nMinInput) nMinInput.value = n;
            if (nMaxInput) nMaxInput.value = n; // Set max to N to ensure it stays in range
            if (xMinInput) xMinInput.value = x;
            if (xMaxInput) xMaxInput.value = x;
            if (yMinInput) yMinInput.value = y;
            if (yMaxInput) yMaxInput.value = y;
            if (zMinInput) zMinInput.value = z;
            if (zMaxInput) zMaxInput.value = z;

            const result = calculateCollatzSequence(n, MAX_ITERATIONS, x, y, z); // Use calculateCollatzSequence
            if (result.type !== "error" && result.type !== "Invalid Parameters (X is 0)") {
                displayMainUniverse({ N: n, X: x, Y: y, Z: z, ...result });
                if (nineNetCanvas) nineNetCanvas.style.display = 'block'; // Ensure main canvas is visible
            } else {
                // Handle error for URL-loaded sequence
                if (paramDisplay) paramDisplay.textContent = `Error for N=${n}, X=${x}, Y=${y}, Z=${z}`;
                if (sequenceInfo) sequenceInfo.textContent = result.type; // Display the error type
                if (sequenceNumbersDiv) sequenceNumbersDiv.textContent = '';
                if (nineNetCanvas) nineNetCanvas.getContext('2d').clearRect(0, 0, nineNetCanvas.width, nineNetCanvas.height);
                if (sequenceRangeInfo) sequenceRangeInfo.textContent = '';
                if (sequenceSumInfo) sequenceSumInfo.textContent = '';
                if (sequenceAvgInfo) sequenceAvgInfo.textContent = '';
                if (sequenceStdDevInfo) sequenceStdDevInfo.textContent = '';
                if (nineNetCanvas) nineNetCanvas.style.display = 'none'; // Hide main canvas on error
            }
        } else {
            // If no parameters, hide the main canvas initially, then `applyAndDrawFilters` will handle it.
            if (nineNetCanvas) nineNetCanvas.style.display = 'none';
            if (paramDisplay) paramDisplay.textContent = 'No specific sequence loaded. Use controls below.';
            if (sequenceInfo) sequenceInfo.textContent = '';
            if (sequenceNumbersDiv) sequenceNumbersDiv.textContent = '';
            if (sequenceRangeInfo) sequenceRangeInfo.textContent = '';
            if (sequenceSumInfo) sequenceSumInfo.textContent = '';
            if (sequenceAvgInfo) sequenceAvgInfo.textContent = '';
            if (sequenceStdDevInfo) sequenceStdDevInfo.textContent = '';
        }

        // Initial draw of bulk universes (always happens regardless of URL params)
        applyAndDrawFilters(); // This will populate the grid with default ranges and potentially update the main display

        // Adjust canvas size if needed for responsiveness (for the single canvas at the top)
        function resizeMainCanvas() {
            if (!nineNetCanvas || !paramDisplay) {
                return;
            }
            const containerWidth = nineNetCanvas.parentElement ? nineNetCanvas.parentElement.clientWidth : NINE_NET_DRAW_WIDTH;
            const desiredDisplayWidth = Math.min(containerWidth * 0.9, NINE_NET_DRAW_WIDTH);
            nineNetCanvas.style.width = `${desiredDisplayWidth}px`;
            nineNetCanvas.style.height = 'auto';

            // Redraw if there's currently a sequence displayed and canvas is visible
            const currentParamsText = paramDisplay.textContent;
            const nMatch = currentParamsText.match(/N=(\d+)/);
            const xMatch = currentParamsText.match(/X=(\d+)/);
            const yMatch = currentParamsText.match(/Y=(\d+)/);
            const zMatch = currentParamsText.match(/Z=(\d+)/);

            const currentN = nMatch ? parseInt(nMatch[1]) : NaN;
            const currentX = xMatch ? parseInt(xMatch[1]) : NaN;
            const currentY = yMatch ? parseInt(yMatch[1]) : NaN;
            const currentZ = zMatch ? parseInt(zMatch[1]) : NaN;

            if (!isNaN(currentN) && !isNaN(currentX) && !isNaN(currentY) && !isNaN(currentZ) && nineNetCanvas.style.display !== 'none') {
                const result = calculateCollatzSequence(currentN, MAX_ITERATIONS, currentX, currentY, currentZ);
                if (result.type !== "error" && result.type !== "Invalid Parameters (X is 0)") {
                    drawNineNetCanvasSecondary(nineNetCanvas, result.sequence, currentX, divColor, mulColor);
                }
            }
        }
        window.addEventListener('resize', resizeMainCanvas);
        resizeMainCanvas();
        updateGoldStarVisibilitySlicer();
    });
</script>
</body>
</html>